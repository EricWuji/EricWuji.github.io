<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>牛客多校1</title>
    <link href="/2024/07/17/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A11/"/>
    <url>/2024/07/17/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A11/</url>
    
    <content type="html"><![CDATA[<h2 id="牛客暑假多校第一场解题报告"><a href="#牛客暑假多校第一场解题报告" class="headerlink" title="牛客暑假多校第一场解题报告"></a>牛客暑假多校第一场解题报告</h2><p><a href="https://ac.nowcoder.com/acm/contest/81596">比赛链接</a></p><h3 id="A-A-Bit-Common"><a href="#A-A-Bit-Common" class="headerlink" title="A. A Bit Common"></a>A. A Bit Common</h3><p><a href="https://ac.nowcoder.com/acm/contest/81596/A">原题链接</a></p><p>题目大意：对于一个序列A（每个数都$\lt 2^m$），存在一个子序列B，使得$AND_{i \in B}B_i=1$，则被计数，问一共有几个这样的序列A，允许有重复数字</p><p>解：我们先钦定有序列A的长度是k，那么这k个数一定都是奇数，换句话说他们二进制的最后一位一定是1，现在考虑前面的$m-1$位，显然，如果我想让他们的AND和是1的话，这$m-1$位一定至少有一个0，所以一共有$\binom{n}{k}\times (2^k-1)^{m-1}$。</p><p>解释一下，$2^k$表示我第i位任意选的情况总数，$2^k-1$表示从这所有的情况中去除全部为1的情况。</p><p>接着我们再去考虑其余$n-k$个数，他们最后一位一定是0，所以他们无论怎么AND，一定不会得到结果1，所以其余的数只要最后一位是0即可，前面$m-1$位任取，一共有方案数$2^{(m-1)\times(n-k)}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;<br>   <span class="hljs-type">int</span> co = <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++) &#123;<br>       a[i][<span class="hljs-number">0</span>] = a[i][i] = <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt; i;j++) &#123;<br>           a[i][j] = (a[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i - <span class="hljs-number">1</span>][j]) % mod;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k &lt;= n;k++) &#123;<br>       <span class="hljs-comment">// co = ((co * (n - k + 1) % mod) % mod * inv % mod) % mod;</span><br>       <span class="hljs-type">int</span> co = a[n][k];<br>       <span class="hljs-type">int</span> res1 = (<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, k) - <span class="hljs-number">1</span> + mod) % mod, res2 = <span class="hljs-built_in">qpow</span>(res1, m - <span class="hljs-number">1</span>), <br>           res3 = <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, m - <span class="hljs-number">1</span>), res4 = <span class="hljs-built_in">qpow</span>(res3, n - k);<br>       ans = (ans + co * res2 % mod * res4 % mod) % mod;<br>   &#125;<br>   cout &lt;&lt; ans &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="B-A-Bit-More-Common"><a href="#B-A-Bit-More-Common" class="headerlink" title="B. A Bit More Common"></a>B. A Bit More Common</h3><p><a href="https://ac.nowcoder.com/acm/contest/81596/B">原题链接</a></p><p>题目大意：与A题不同的是，这道题目要求序列A存在至少两个子序列B，使得$AND_{i\in B}B_i = 1$</p><p>解：承接第一道题目的思路，我们在A题中已经得到存在至少一个子序列的个数了，是不是只需要减去存在严格等于1的方案数，剩下来的就是我B的方案数。</p><p>那么我该怎么算出这些严格等于1的方案数呢？</p><p>我们给出以下定义：如果某一位的数字中只有一个0，那么这位数就是不可或缺的，我们称这样的位为特殊位。注意：这里我们不讨论这$i$个数具体是什么，只谈论这一位的数字分布情况，当然了，我们讨论的前提都是这个序列A满足$AND_{i\in A}A_i=1$。</p><p>显然，如果一个序列A只有一个子序列AND=0，则序列A中的每一个数字都至少都对应这一个特殊位：因为如果某一个数字对应两个及以上的特殊位的话，这个数字完全可以被删去，不符合我们的定义。</p><p>我们设$dp[i][j]$表示$i$个数字对应$j$个特殊位有几种方案数。有如下转移$dp[i][j]= i \times(dp[i][j-1]+dp[i-1][j-1])$。</p><p>为什么呢？如下图（图片里下标好像写错了，是从1开始的，而不是0）：</p><p><img src="/2024/07/17/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A11/B.jpg" alt></p><p>对于从$dp[i][j-1]$转移过来的情况，我的第j位可以在i个数中任选一个，有贡献$i\times dp[i][j-1]$</p><p>对于从$dp[i-1][j-1]$转移过来的情况（此时我们认为新增的特殊位就在i上），我新增的数可以放在任意一个位置上，所以也有贡献$i\times dp[i1-][j-1]$</p><p>最后可以求得严格等于1的方案数为$\sum_{i=k}^{m-1} \binom{m-1}{i}(2^k-k-1)^{m-1-k}dp[k][i]$</p><p>最后的答案就是A的答案减去严格等于1的答案。</p><p>NOTE：用板子会快一点。</p><h3 id="D-XOR-of-Suffix-Sums"><a href="#D-XOR-of-Suffix-Sums" class="headerlink" title="D. XOR of Suffix Sums"></a>D. XOR of Suffix Sums</h3><p><a href="https://ac.nowcoder.com/acm/contest/81596/D">原题链接</a></p><p>题目大意：在线查询数组后缀和的异或和</p><p>解：这个模数十分特别刚好是$2^{21}$，所以暗示我们可以按位维护我要的答案。</p><p>一个后缀可以转换为两个前缀和的差，有$sum[n]-sum[i-1]=suf[i]$，因此这道题目需要我们维护一个值域树状数组，维护的值域都是$-sum[i]$，其中$-sum[n]$不会在树状数组中维护。</p><p>现在我想要知道第$d$位一共有奇数个还是偶数个1，观察可得如下结论：若$sum[n]-sum[i-1] \mod{2^{d+1}} \ge 2^{d}$则$sum[i-1]$在$d$位贡献了1，我们可以利用这个式子得到如下结论：</p><p>$2^{d+1} \gt (sum[n]-x) \mod{2^{d+1}} \ge2^d \\ \Rightarrow 2^{d+1} - sum[n] \mod{2^{d+1}} \gt -x \ge 2^d-sum[n] \mod{2^{d+1}}$</p><p>得到了我要查询的x所在的上下界，分别是$l=2^d-sum[n] \mod{2^{d+1}},\quad  r=2^{d+1}-sum[n] \mod{2^{d+1}}$</p><p>当我的$l \le r$时，正常查询，当我的$r \lt l$时需要查询$[0,r]\cup[l,2^{d+1}]$。为什么，可以理解为因为有取模的存在导致原本在$l$后面的$r$重新出现在了$l$的前面，这是$[r+ 1,l -1]$的区间是不用查询的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> q;<br>   cin &gt;&gt; q;<br>   <span class="hljs-keyword">while</span> (q --) &#123;<br>       <span class="hljs-type">int</span> t, v;   cin &gt;&gt; t &gt;&gt; v;<br>       <span class="hljs-keyword">while</span> (t--) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, mod;i &lt;= <span class="hljs-number">20</span>;i++) &#123;<br>               mod = <span class="hljs-number">1</span> &lt;&lt; (i + <span class="hljs-number">1</span>);<br>               tr[i].<span class="hljs-built_in">update</span>((mod - sum[n - <span class="hljs-number">1</span>] % mod) % mod, <span class="hljs-number">-1</span>);<br>           &#125;<br>           n --;<br>       &#125;       <br>       n ++; sum[n] = (sum[n - <span class="hljs-number">1</span>] + v) % MOD;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, mod;i &lt;= <span class="hljs-number">20</span>;i++) &#123;<br>           mod = <span class="hljs-number">1</span> &lt;&lt; (i + <span class="hljs-number">1</span>);<br>           tr[i].<span class="hljs-built_in">update</span>((mod - sum[n - <span class="hljs-number">1</span>] % mod + mod) % mod, <span class="hljs-number">1</span>);<br>       &#125;<br>       <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-number">20</span>;i++) &#123;<br>           <span class="hljs-type">int</span> mod = <span class="hljs-number">1</span> &lt;&lt; (i + <span class="hljs-number">1</span>), tmp = <span class="hljs-number">1</span> &lt;&lt; i;<br>           <span class="hljs-type">int</span> l = ((tmp - sum[n] % mod) + mod) % mod;<br>           <span class="hljs-type">int</span> r = ((mod - sum[n] % mod) - <span class="hljs-number">1</span> + mod) % mod; <br>           <span class="hljs-keyword">if</span> (l &lt;= r) &#123;<br>               cnt = tr[i].<span class="hljs-built_in">query</span>(l, r);<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               cnt = tr[i].<span class="hljs-built_in">query</span>(<span class="hljs-number">0</span>, r) + tr[i].<span class="hljs-built_in">query</span>(l, mod);<br>           &#125;<br>           <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) ans |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>       &#125;<br>       cout &lt;&lt; ans &lt;&lt; endl;<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>组合数学</title>
    <link href="/2024/07/10/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    <url>/2024/07/10/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="例1-硬币购物"><a href="#例1-硬币购物" class="headerlink" title="例1.硬币购物"></a>例1.硬币购物</h3><p><a href="https://www.luogu.com.cn/problem/P1450">原题链接</a></p><p>解：这道题目的dp非常巧妙，如果看不懂就死记硬背下来吧。</p><p>由于这道题目中中硬币的面值是给定且不会发生变化的。所以我们可以利用完全背包，预处理出$dp[i]$，$dp[i]$表示组成$i$元一共有几种方式（没有限制）。</p><p>但是这道问题是有限制的。我们如何利用没有限制的方案数去推导有限制的方案数呢？答案是利用容斥原理。</p><p>例如说，对于$i$物品，有$d[i]$的限制，如果我们只考虑这一个物品有限制的话，我们完全可以强行取出$d[i]+1$个面值为$c[i]$的硬币。所以对于有$d[i]$限制的物品，我们的方案数就是$dp[i-(d[i]+1)\times c[i]]$。</p><p>再解释以下这里的$dp[i-(d[i]+1)\times c[i]]$是怎么得到的。为什么$dp[j-(d[i]+1)\times c[i]]$中会存在选择$(d[i]+2)\times c[i]$的情况？因为有$(d[i]+1)\times c[i] \lt (d[i]+2)\times c[i] \Rightarrow (j-(d[i]+1) \times c[i]) \gt (j-(d[i]+2) \times c[i])$。所以说$dp[j-(d[i]+1)\times c[i]]$是包含了这种情况的。</p><p>而对于整个答案的容斥，事实上就是$无限制的情况-(有一个限制)+(有两个限制)-……$，这就是最简单的容斥原理了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++) c[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>, <span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = c[i];j &lt;= <span class="hljs-number">1e5</span>;j++)<br>            dp[j] += dp[j - c[i]];<br>    &#125;<br><br>    <span class="hljs-type">int</span> T = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++) d[i] = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-type">int</span> s = <span class="hljs-built_in">read</span>(), ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> status = <span class="hljs-number">0</span>;status &lt;= <span class="hljs-number">15</span>;status++) &#123;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">4</span>;i++) &#123;<br>                <span class="hljs-keyword">if</span> (status &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) &#123;<br>                    cnt += (d[i] + <span class="hljs-number">1</span>) * c[i];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s - cnt &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (__popcount(status) &amp; <span class="hljs-number">1</span>) &#123;<br>                ans -= dp[s - cnt];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans += dp[s - cnt];<br>            &#125;<br>        &#125; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2024河北工大解题报告</title>
    <link href="/2024/07/08/2024%E6%B2%B3%E5%8C%97%E5%B7%A5%E5%A4%A7%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/2024/07/08/2024%E6%B2%B3%E5%8C%97%E5%B7%A5%E5%A4%A7%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><p><a href="https://ac.nowcoder.com/acm/contest/84781">比赛链接</a></p><h3 id="F-循环移位"><a href="#F-循环移位" class="headerlink" title="F.循环移位"></a>F.循环移位</h3><p><a href="https://ac.nowcoder.com/acm/contest/84781/F">原题链接</a></p><p>题目大意：首先我们定义以下概念</p><p><img src="/2024/07/08/2024%E6%B2%B3%E5%8C%97%E5%B7%A5%E5%A4%A7%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/Users\11506\test\source\_posts\2024河北工大解题报告\F.png" alt></p><p>现在给你n个整数，你必须分别做一次$L(x),R(y),x \ne y$，问最大的异或和是多少</p><p>解：</p><p>我们令$res=a_1 \land a_2 \land… \land a_n$，假设我选取了$i,j分别做L(i),R(j)$那么我的答案就是$res \land x_i \land L(i) \land x_j\land R(j)$，我们再令$ls(i)=x_i\land L(i),rs(j)=x_j\land R(j)$，则我的答案又可以写做$res \land ls(i) \land rs(j)$</p><p>那么此时我们可以考虑把$rs(i)$全部存放在trie中，枚举$res\land ls(i)$的值，在trie中找最大的异或值</p><p>特别需要注意的是，由于$i \ne j$所以在找最大异或值的时候需要先把$ls(i)$从trie中删除</p><p>代码如下，特别注意其中的remove操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    <span class="hljs-type">bool</span> isEnd;<br>    <span class="hljs-type">int</span> cnt;<br>    vector&lt;Node *&gt; children;<br>    <span class="hljs-built_in">Node</span>() : <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>), <span class="hljs-built_in">cnt</span>(<span class="hljs-number">0</span>)<br>    &#123;<br>        children.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span>);<br>        children[<span class="hljs-number">0</span>] = children[<span class="hljs-number">1</span>] = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    Node* root;<br>    <span class="hljs-built_in">Trie</span>() &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Node *u = root;<br>        u-&gt;cnt += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-type">int</span> tmp = (x &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (u-&gt;children[tmp] == <span class="hljs-literal">nullptr</span>)<br>                u-&gt;children[tmp] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>            u = u-&gt;children[tmp];<br>            u-&gt;cnt += <span class="hljs-number">1</span>;<br>        &#125;<br>        u-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Node *u = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-type">int</span> tmp = (x &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            u-&gt;cnt -= <span class="hljs-number">1</span>;<br>            u = u-&gt;children[tmp];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Node *u = root;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-type">int</span> tmp = (x &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (u-&gt;children[tmp ^ <span class="hljs-number">1</span>] == <span class="hljs-literal">nullptr</span> || u-&gt;children[tmp ^ <span class="hljs-number">1</span>]-&gt;cnt == <span class="hljs-number">0</span>) &#123;<br>                u = u-&gt;children[tmp];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <br>            ans |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>            u = u-&gt;children[tmp ^ <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br>Trie tr;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">L</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ((x ^ (<span class="hljs-number">1</span> &lt;&lt; __lg(x))) &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">R</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ((x &gt;&gt; <span class="hljs-number">1</span>) | ((x &amp; <span class="hljs-number">1</span>) &lt;&lt; __lg(x)));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(), xornums = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">l</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">r</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        a[i] = <span class="hljs-built_in">read</span>();<br>        xornums ^= a[i];<br>        l[i] = a[i] ^ <span class="hljs-built_in">L</span>(a[i]);<br>        r[i] = a[i] ^ <span class="hljs-built_in">R</span>(a[i]);<br>        tr.<span class="hljs-built_in">insert</span>(r[i]);<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> tmp = xornums ^ l[i];<br>        tr.<span class="hljs-built_in">remove</span>(r[i]);<br>        ans = <span class="hljs-built_in">max</span>(ans, tr.<span class="hljs-built_in">query</span>(tmp));<br>        tr.<span class="hljs-built_in">insert</span>(r[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="J-大炮运输"><a href="#J-大炮运输" class="headerlink" title="J.大炮运输"></a>J.大炮运输</h3><p><a href="https://ac.nowcoder.com/acm/contest/84781/J">原题链接</a></p><p>解：一道很显然的dp，我们可以设$dp[i]$表示到达i号炮台的最小代价，显然，我们有如下转移方程$dp[i]=\min_{j=1}^{i-1}{(dp[j]+a_j(i-j)^3+b_j)}$，但是这个转移方程的时间复杂度是$O(n^2)$，所以我们尝试减少复杂度。</p><p>有什么情况跳着走永远比一步一步跳代价要大呢，假设我是一步一步跳的，有$cost1=\sum_j^{i-1}(a[i]+b[i])$。</p><p>如果我是跳着走的，有$cost2=a[j]\times (i-j)^3+b[j]$ 。</p><p>根据数据范围$a[i],b[i] \le 1e5$，有$cost1\le 2e5\times(i-j)$，$cost2 \ge (i-j)^3$，联立有$(i-j)^3 \ge 2e5\times(i - j)$，化简得,$i-j\ge\sqrt{2e5} = 500$，即转移的范围不会超过500。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>重链剖分</title>
    <link href="/2024/07/05/%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86/"/>
    <url>/2024/07/05/%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="重链剖分"><a href="#重链剖分" class="headerlink" title="重链剖分"></a>重链剖分</h2><h3 id="1-重链剖分的板子"><a href="#1-重链剖分的板子" class="headerlink" title="1.重链剖分的板子"></a>1.重链剖分的板子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfsFir</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> pre)</span> </span>&#123;<br>    siz[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[v, w] : edge[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == pre) <span class="hljs-keyword">continue</span>;<br>        dep[v] = dep[u] + <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">dfsFir</span>(v, u);<br>        val[v] = w;<br>        siz[u] += siz[v], fa[v] = u;<br>        <span class="hljs-keyword">if</span> (siz[son[u]] &lt; siz[v]) son[u] = v;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//其中这里的seg[i]表示线段树上的i位置对应在树上的位置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfsSec</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> tp)</span> </span>&#123;<br>    dfn[u] = ++timer, seg[timer] = u, top[u] = tp;<br>    <span class="hljs-keyword">if</span> (son[u]) <span class="hljs-built_in">dfsSec</span>(son[u], tp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[v, w] : edge[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa[u] || v == son[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfsSec</span>(v, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-把边权转移到点权上"><a href="#2-把边权转移到点权上" class="headerlink" title="2.把边权转移到点权上"></a>2.把边权转移到点权上</h3><p><a href="https://www.luogu.com.cn/problem/P3038">原题链接</a></p><p>解：对于$(u,v)$这条边，其中边权为$w$，我们该如何把这条边转移到点权上呢？只需要让深度大的点存这个边权即可。</p><p><img src="/2024/07/05/%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86/边权转点权.jpg" alt></p><p>例如在上图中，假设以1为根节点，则$(1,2)$的这条边权转换为2的点权；同理$(3,4)$的边权也可以转换为4的点权</p><p>那么我们在维护边权信息的时候与点权时有什么不同呢？</p><p>1.对于$l$到$r$路径上的边权都$+val$的情况，我们可以把他转换为$l$到$r$路径上的点权都$+val$，之后对于$lca(l,r)$节点$-val$。</p><p>为什么最后要减去？因为$lca(l,r)$代表的边权是$(fa[lca],lca)$，并不在$l$到$r$的路径上。</p><p>2.对于查询$l$到$r$路径上的边权和，与1同理，我要的答案就是$l$到$r$的点权和，再减去$lca(l,r)$的点权</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数论基础</title>
    <link href="/2024/07/03/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/07/03/%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="数论基础"><a href="#数论基础" class="headerlink" title="数论基础"></a>数论基础</h2><h3 id="1-拓展欧几里得"><a href="#1-拓展欧几里得" class="headerlink" title="1.拓展欧几里得"></a>1.拓展欧几里得</h3><p>拓展欧几里得就是求形如$ax+by=\gcd(a,b)$的整数解的一组特解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//ax + by = d</span><br><span class="hljs-comment">//这个模板中的d = gcd(a, b) 顺便也求出来了</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;d, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span> </span>&#123;   <br>    <span class="hljs-keyword">if</span> (!b) d = a, x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">exgcd</span>(b, a % b, d, y, x), y -= x * (a / b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-裴蜀定理"><a href="#2-裴蜀定理" class="headerlink" title="2.裴蜀定理"></a>2.裴蜀定理</h3><p>对于一个不定方程$ax+by=c$，有整数解的充要条件是$c\mid \gcd(a,b)$</p><p>更进一步，有对于不定方程$a_1x_1+a_2x_1+a_3x_3+…+a_n x_n=d$，有整数解的充要条件是$d\mid \gcd(a_1,a_2,…a_n)$</p><h3 id="3-线性筛素数"><a href="#3-线性筛素数" class="headerlink" title="3.线性筛素数"></a>3.线性筛素数</h3><p>代码中$isPrime[i]$表示i是否是质数，$primes[i]$表示第i小的质数是多少</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">memset</span>(isPrime, <span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(isPrime));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i &lt;= N;i++) &#123;<br><span class="hljs-keyword">if</span> (isPrime[i]) <br>       primes[++cnt] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= cnt &amp;&amp; i * primes[j] &lt;= N;j++) &#123;<br>        isPrime[i * primes[j]] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-求乘法逆元"><a href="#4-求乘法逆元" class="headerlink" title="4.求乘法逆元"></a>4.求乘法逆元</h3><h4 id="1-求单个整数的乘法逆元"><a href="#1-求单个整数的乘法逆元" class="headerlink" title="1.求单个整数的乘法逆元"></a>1.求单个整数的乘法逆元</h4><p>一般来说我们要求的mod都是一个质数，所以我们可以直接利用$a^{p-2} \equiv 1\pmod p$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (;b;b &gt;&gt;= <span class="hljs-number">1</span>, a = a * a % mod)<br>        <span class="hljs-keyword">if</span> (a &amp; <span class="hljs-number">1</span>) ans = a * ans % mod;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-type">int</span> inv_x = <span class="hljs-built_in">qpow</span>(x, mod - <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h4 id="2-求解一个线性同余方程"><a href="#2-求解一个线性同余方程" class="headerlink" title="2.求解一个线性同余方程"></a>2.求解一个线性同余方程</h4><p>求解形如$ax \equiv b \pmod p$的方程</p><p>解：$ax \equiv b \pmod p \Rightarrow ax-b=py \Rightarrow ax-py=b \Rightarrow ax+py’=b$</p><p>其实就是求解$ax+py=b$这样一个不定方程，用拓展欧几里得实现</p><h4 id="3-线性求解n个数的逆元：给你n个整数让你求出他们的逆元"><a href="#3-线性求解n个数的逆元：给你n个整数让你求出他们的逆元" class="headerlink" title="3.线性求解n个数的逆元：给你n个整数让你求出他们的逆元"></a>3.线性求解n个数的逆元：给你n个整数让你求出他们的逆元</h4><p>我们设$s[i]=\prod_{i=1}^na[i]$，那么有$s_{i-1}<em>a_i=s_i$，两边同时除$s_{i-1}</em>s_i$，得$a_i<em>s_i^{-1}=s_{i-1}^{-1}$，即$a_i</em>inv[s_i]=inv[s_{i-1}]$，</p><p>故我们可以线性求出所有的$inv[s[i]]$，同样的我们可以把方程变为$a_i^{-1}=s_{i-1}<em>s_i^{-1}$，即$inv[a_i]=s_{i-1}</em>inv[s_i]$，故我们也可以线性的求出所有$a_i$的逆元</p><h4 id="4-线性求解所有-1-n-的逆元"><a href="#4-线性求解所有-1-n-的逆元" class="headerlink" title="4.线性求解所有$[1,n]$的逆元"></a>4.线性求解所有$[1,n]$的逆元</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树型DP</title>
    <link href="/2024/06/28/%E6%A0%91%E5%9E%8BDP/"/>
    <url>/2024/06/28/%E6%A0%91%E5%9E%8BDP/</url>
    
    <content type="html"><![CDATA[<h2 id="树型DP"><a href="#树型DP" class="headerlink" title="树型DP"></a>树型DP</h2><h3 id="选择节点类的题目"><a href="#选择节点类的题目" class="headerlink" title="选择节点类的题目"></a>选择节点类的题目</h3><h4 id="例1-没有上司的舞会"><a href="#例1-没有上司的舞会" class="headerlink" title="例1. 没有上司的舞会"></a>例1. 没有上司的舞会</h4><p><a href="https://www.luogu.com.cn/problem/P1352">原题链接</a></p><p>解：我们设$dp[i][0/1]$分别表示 选/不选 第$i$个人的最大快乐值，设当前节点为u，u的儿子为v，$a[i]$表示i的快乐值</p><p>那么，我们可以列出他的转移方程：</p><p>$\begin{cases} \begin{aligned} dp[u][0] &amp;=\sum \max{(dp[v][0],dp[v][1])} \\ dp[u][1] &amp;=\sum \max{(dp[v][0],dp[v][1])+a[u]} \end{aligned} \end{cases}$</p><p>我们利用dfs的方式即可实现功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> ok)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dp[u][ok] != LONG_LONG_MIN) &#123;<br>        <span class="hljs-keyword">return</span> dp[u][ok];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!ok) &#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : edge[u]) &#123;<br>            ans += <span class="hljs-built_in">dfs</span>(it, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[u][ok] = ans;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : edge[u]) &#123;<br>            ans += <span class="hljs-built_in">dfs</span>(it, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> ans2 = r[u];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : edge[u]) &#123;<br>            ans2 += <span class="hljs-built_in">dfs</span>(it, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[u][ok] = <span class="hljs-built_in">max</span>(ans, ans2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树上背包问题"><a href="#树上背包问题" class="headerlink" title="树上背包问题"></a>树上背包问题</h3><h4 id="例1-有线电视网"><a href="#例1-有线电视网" class="headerlink" title="例1. 有线电视网"></a>例1. 有线电视网</h4><p><a href="https://www.luogu.com.cn/problem/P1273">原题链接</a></p><p>解：我们设$dp[i][j]$表示以i为根的子树中，满足j个人需求的最大利润。其中第$i$条边的成本为$c[i]$，第i个人愿意交的钱为$a[i]$，$cost[i][j]$表示从i到j的成本</p><p>那么我们怎么去求$dp[u][j]$呢？首先我们肯定要遍历u的所有儿子v，但是对于不同的v，我们可以选择不同的$dp[v][j’]$，来使得我的$dp[u][j]$最大。很显然，任意的$dp[v][j’]$是已知的，所以这道题就变成了一道背包问题，即已知背包容量为j，我有若干个物品，价值为$dp[v][j’]$，重量为$j’$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (leaf[u]) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : edge[u]) <span class="hljs-built_in">dfs</span>(it), siz[u] += siz[it];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : edge[u]) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = siz[u];j &gt;= <span class="hljs-number">1</span>;j--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k &lt;= siz[u];k++) &#123;<br>                dp[u][j] = <span class="hljs-built_in">max</span>(dp[u][j], dp[u][j - k] + dp[it][k] - cost[u][it]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么以上代码需要我记录$siz[u]$，因为对于以i为根的子树，他最多也就能满足$siz[i]$个人</p><h4 id="例2-树上染色"><a href="#例2-树上染色" class="headerlink" title="例2. 树上染色"></a>例2. 树上染色</h4><p><a href="https://www.luogu.com.cn/problem/P3177">原题链接</a></p><p>解：我们设$dp[i][j]$表示以i为根的子树中染了j个黑色的点，对答案的贡献。一共要涂m个黑点</p><p>由此我们可以列出状态转移方程，对于从u到v的路径    ，长度为w，有$dp[u][j]=\max(\sum dp[v][j’]+tot*w)$</p><p>其中我的tot表示，w对答案的贡献，其中$tot=j<em>(m-j)+(siz[v]-j)</em>(n-siz[v]+j-m)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> pre)</span> </span>&#123;<br>    siz[u] = <span class="hljs-number">1</span>, dp[u][<span class="hljs-number">0</span>] = dp[u][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u];i;i = e[i].nxt) &#123;<br>        <span class="hljs-type">int</span> v = e[i].to, weight = e[i].weight;<br>        <span class="hljs-keyword">if</span> (v == pre) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(v, u);<br>        siz[u] += siz[v];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-built_in">min</span>(m, siz[u]);j &gt;= <span class="hljs-number">0</span>;j--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k &lt;= <span class="hljs-built_in">min</span>(j, siz[v]);k++) &#123;<br>                <span class="hljs-keyword">if</span> (dp[v][k] == <span class="hljs-number">-1</span> || dp[u][j - k] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> tot = k * (m - k) + (siz[v] - k) * (n - m - siz[v] + k);<br>                dp[u][j] = <span class="hljs-built_in">max</span>(dp[u][j], dp[u][j - k] + dp[v][k] + tot * weight);<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="换根DP"><a href="#换根DP" class="headerlink" title="换根DP"></a>换根DP</h3><h4 id="例1-STA-station"><a href="#例1-STA-station" class="headerlink" title="例1. STA-station"></a>例1. STA-station</h4><p><a href="https://www.luogu.com.cn/problem/P3478">原题链接</a></p><p>解：设$dp[i]$表示以i为根的时候，深度和是多少。</p><p>对于换根DP来说，一般都需要dfs两遍，例如在本题中，第一次dfs，能够求出以1为根的深度和，即$dp[1]$</p><p>第二次dfs时，从以u为根到以v为根，如下图所示：</p><p><img src="/2024/06/28/%E6%A0%91%E5%9E%8BDP/page.jpg" alt></p><p>我们可以看到对于v的子树，他的dep都是-1，其余的dep都是+1</p><p>所以$dp[v]=dp[u]-(n-siz[v])+siz[v]=dp[u]+2*siz[v]-n$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> pre)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : edge[u]) &#123;<br>        <span class="hljs-keyword">if</span> (it == pre) <span class="hljs-keyword">continue</span>;<br>        dep[it] = dep[u] + <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">dfs</span>(it, u);<br>        siz[u] += siz[it];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DP</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> pre)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : edge[u]) &#123;<br>        <span class="hljs-keyword">if</span> (it == pre) <span class="hljs-keyword">continue</span>;<br>        dp[it] = dp[u] + (n - siz[it]) - siz[it];<br>        <span class="hljs-keyword">if</span> (dp[it] &gt; ans) ans = dp[it], idx = it;<br>        <span class="hljs-built_in">DP</span>(it, u);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>区间DP</title>
    <link href="/2024/06/26/%E5%8C%BA%E9%97%B4DP/"/>
    <url>/2024/06/26/%E5%8C%BA%E9%97%B4DP/</url>
    
    <content type="html"><![CDATA[<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h3 id="例1-关路灯"><a href="#例1-关路灯" class="headerlink" title="例1. 关路灯"></a>例1. 关路灯</h3><p><a href="https://www.luogu.com.cn/problem/P1220">原题连接</a></p><p>大意：给你初始位置$x_0$以及每个路灯的位置$x_i$和功率$p_i$，你的速度为1$m/s$，问关闭所有路灯后，最小的能耗</p><p>解：</p><p>规定$sum_k=\sum_{i=1}^{k}p_i$</p><p>设$dp[i][j][0/1]$表示关闭$[i,j]$的所有路灯后，你停留在i位置(0)或者j位置(1)的最小能耗</p><p>那么对于$dp[i][j][0/1]$有两种转移策略：</p><p>​    第一种策略：$dp[i][j]从dp[i + 1][j]$转移过来；       第二种策略：$dp[i][j]从dp[i][j+1]$转移过来</p><p>所以对于$dp[i][j][0]$，他只会从$dp[i+1][j][0],dp[i+1][j][1]$转移过来：</p><p>​    如果他从$dp[i+1][j][0]$转移过来，有：$dp[i][j][0]=dp[i+1][j][0]+(x_{i+1}-x_i)*(sum_{n}+sum_i-sum_j)$</p><p>​    如果他从$dp[i+1][j][1]$转移过来：有：$dp[i][j][0]=dp[i+1][j][1]+(x_j-x_i)*(sum_{n}+sum_i-sum_j)$</p><p>解释一下$sum_{n}+sum_i-sum_j$，因为我最后要站在i位置上，所以位置$[i+1,j]$的灯都是关上的，他们的功率和是$sum_j-sum_{i}$</p><p>所以剩下的在工作的功率就是$sum_n-sum_j+sum_i$</p><p>同理对于$dp[i][j][1]$，他只会从$dp[i][j-1][0],dp[i][j-1][1]$转移过来：</p><p>​    如果他从$dp[i][j-1][0]$转移过来，有：$dp[i][j][1]=dp[i][j-1][0]+(x_j-x_i)*(sum_n-sum_{j-1}+sum_{i-1})$</p><p>​    如果他从$dp[i][j-1][1]$转移过来，有：$dp[i][j][1]=dp[i][j-1][1]+(x_j-x_{j-1})*(sum_n-sum_{j-1}+sum_{i-1})$</p><p>解释一下$sum_n-sum_{j-1}+sum_{i-1}$，因为我最后要站在j位置上，所以位置$[i,j-1]$的灯都是关上的，他们的功率和是$sum_{j-1}-sum_{i-1}$，所以剩下的在工作的灯的总功率是$sum_n-sum_{j-1}+sum_{i-1}$</p><hr><p>关于赋初值的问题，我们只需要吧初始位置$x_0$的dp设置为0即可，即$dp[x_0][x_0][0] = dp[x_0][x_0][1]=0$</p><p>其余的位置我可以不去管他，因为他是从i出发的</p><h3 id="例2-涂色"><a href="#例2-涂色" class="headerlink" title="例2. 涂色"></a>例2. 涂色</h3><p><a href="https://www.luogu.com.cn/problem/P4170">原题连接</a></p><p>大意：给你一个长度为n的木板，涂成给定的颜色状态，其中对于相同的位置，先刷上的颜色会被后刷上的颜色覆盖，问最小的涂色次数</p><p>解：</p><p>我们设$dp[i][j]$表示把位置$[i,j]$涂成目标状态的最小涂色次数</p><p>那么，对于任意的i，有$dp[i][i]=1$，一个点，最小的次数一定是1</p><hr><p>对于$i\ne j \land s[i]==s[j]$，那么$dp[i][j]=min(dp[i][j-1],dp[i+1][j])$</p><p>为什么？对于$dp[i][j-1]$，我在涂色$[i,j-1]$时，是可以把$s[i]$也考虑进来的($s[i]==s[j]$)，也就是说我可以先把$[i,j]$全部涂色成$s[i]$的颜色，之后再在$[i,j-1]$上找最优秀的涂色方式。</p><p>问题：把整个区间涂色之后不会导致我的$dp[i][j-1]$不成立吗？不会。因为先涂色的会被覆盖，刷的范围越大，只会对结果更有利</p><hr><p>对于$i \ne j \land s[i]\ne s[j]$，那么$dp[i][j] = \max_{k=i}^{j}{dp[i][k]+dp[k+1][j]}$，就是两个区间的和</p><p>问题1：两个区间不会出现两者中间有连续一段相同的颜色，可以一步到位吗？会出现，但是我的k会枚举到他们分别在两个区域中的情况</p><p>问题2：会不会出现先把$[i,j]$都刷成某一种颜色，再进行涂色，使得方案更优？会出现，但是因为这里$s[i]\ne s[j]$所以当我的$k=i||k=j-1$时，实际上我的$dp[i][k]+dp[k+1][j]$就是问题2中描述的情况($dp[i][i] = dp[j][j]=1$)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>”区间DP“</title>
    <link href="/2024/06/26/%E2%80%9D%E5%8C%BA%E9%97%B4DP%E2%80%9C/"/>
    <url>/2024/06/26/%E2%80%9D%E5%8C%BA%E9%97%B4DP%E2%80%9C/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>后缀的一些运用1</title>
    <link href="/2024/06/10/%E5%90%8E%E7%BC%80%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%90%E7%94%A81/"/>
    <url>/2024/06/10/%E5%90%8E%E7%BC%80%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%90%E7%94%A81/</url>
    
    <content type="html"><![CDATA[<h1 id="后缀数组的一些运用和小结论1"><a href="#后缀数组的一些运用和小结论1" class="headerlink" title="后缀数组的一些运用和小结论1"></a>后缀数组的一些运用和小结论1</h1><h3 id="1-最长重复子串"><a href="#1-最长重复子串" class="headerlink" title="1.最长重复子串"></a>1.最长重复子串</h3><p><a href="https://leetcode.cn/problems/longest-duplicate-substring/description/">原题地址</a></p><p>题目大意：给你一个字符串，让你求出至少出现两次的最长子串</p><p>解：这是一道板子题，所谓至少出现两次，其实就是我的$hegiht[i]$，即我的$lcp(s_1,s_2)$。所以我只要求出所有的height取最大值即可</p><p>时间复杂度$O(n\log n)$</p><h3 id="2-字符加密"><a href="#2-字符加密" class="headerlink" title="2.字符加密"></a>2.字符加密</h3><p><a href="https://www.luogu.com.cn/problem/P4051">原题地址</a></p><p>解：看到环形字符串，下意识就会把它复制一份拼上。之后直接跑一个SA，收集答案时，对于$sa[i]&gt;n$的情况，我们不做处理，因为他不在我要的$[1,n]$的区间内。</p><h3 id="3-New-Distinct-Substrings"><a href="#3-New-Distinct-Substrings" class="headerlink" title="3.New Distinct Substrings"></a>3.New Distinct Substrings</h3><p><a href="https://www.luogu.com.cn/problem/SP705">原题地址</a></p><p>题目大意：给你一个字符串问有几个本质不同的子串，即若子串形态相同，位置不同，算同一种</p><p>解：我们先考虑在sa排序上相邻的两个子串，可以发现$sa[i-1]$可以代表$len(sa[i-1])$种子串，同理$sa[i]$可以代表$len(sa[i])$种子串，他们之间有$len(lcp(sa[i-1],sa[i]))= height[i]$，也就意味着他们有$height[i]$个子串是本质相同的。故$sa[i]和sa[i-1]$对答案的贡献为$len(sa[i-1])+len(sa[i])-height[i]$，对于整个字符串一共有后缀$\frac{n*(n+1)}{2}$个，也就是$\sum_{i=1}^nlen(sa[i])$</p><p>所以最后的答案为$\frac{n*(n+1)}{2}-\sum_{i=1}^n height[i]$</p><h3 id="4-NSUBSTR-Substrings"><a href="#4-NSUBSTR-Substrings" class="headerlink" title="4.NSUBSTR - Substrings"></a>4.NSUBSTR - Substrings</h3><p><a href="https://www.luogu.com.cn/problem/SP8222">原题地址</a></p><p>题目大意：给你一个字符串，问长度为$[1,n]$的子串最多出现了多少次</p><p>解：首先我们通过SA可以得到SA中相邻两个字符串的lcp，对于任意两个字符串，有$lcp(s_1,s_2)=\min_{k=i}^j(height[k])$，因此对于长度为L的一个子串，它出现的最多次数，就是在SA上连续$height[i]\ge L$的最长长度，因为他们的lcp是连续的。</p><p>如何求出这个长度呢？使用单调栈，先从左往右扫一遍，得到满足$height[i]\ge L$的最左端点位置，再从右往左扫一遍，得到满足$height[i]\ge L$的最右端位置，最后枚举每个位置计算$len[i]=right[i]-left[i]+2$（包括左右端点）</p><p>最后算答案的时候，需要利用长度长的出现次数来更新，长度短的出现次数，因为它可能没有被统计到</p><p>单调栈代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mono_stack</span> &#123;<br><span class="hljs-type">int</span> stk[MAXN], top;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">1</span> &amp;&amp; height[stk[top]] &gt;= height[x]) -- top;<br>stk[++top] = x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">back</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> stk[top - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>top = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;;<br>mono_stack stk;<br><span class="hljs-type">int</span> ll[MAXN], rr[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>stk.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)stk.<span class="hljs-built_in">push</span>(i), ll[i] = stk.<span class="hljs-built_in">back</span>() + <span class="hljs-number">1</span>;<br>stk.<span class="hljs-built_in">clear</span>(), stk.<span class="hljs-built_in">push</span>(n + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n;i &gt;= <span class="hljs-number">1</span>;i--) stk.<span class="hljs-built_in">push</span>(i), rr[i] = stk.<span class="hljs-built_in">back</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) times[height[i]] = <span class="hljs-built_in">max</span>(times[height[i]], rr[i] - ll[i] + <span class="hljs-number">2</span>);<br>times[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n;i &gt;= <span class="hljs-number">1</span>;i--) times[i] = <span class="hljs-built_in">max</span>(times[i], times[i + <span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>后缀数组SA</title>
    <link href="/2024/06/09/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84SA/"/>
    <url>/2024/06/09/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84SA/</url>
    
    <content type="html"><![CDATA[<h1 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h1><h3 id="1-后缀数组用来解决什么问题"><a href="#1-后缀数组用来解决什么问题" class="headerlink" title="1. 后缀数组用来解决什么问题"></a>1. 后缀数组用来解决什么问题</h3><p>​    对于一个str，我们设$suf(x)$表示str从x位置开始的后缀，例如str=<strong><em>“abababa“</em></strong>,则$suf(3)=ababa$</p><p>​    另外我们定义$lcp(suf_i,suf_j)$表示i和j两个字符串的最长公共前缀</p><p>​    要求我们把后缀$suf(1),suf(2),……,suf(n)$按照字典序从小到大排序好，得到一个后缀数组</p><h3 id="2-如何得到后缀数组"><a href="#2-如何得到后缀数组" class="headerlink" title="2. 如何得到后缀数组"></a>2. 如何得到后缀数组</h3><h4 id="方法1：-暴力sort"><a href="#方法1：-暴力sort" class="headerlink" title="方法1： 暴力sort"></a>方法1： 暴力sort</h4><p>​        对于一个str，我们有n个后缀，利用sort暴力排序，一共有n个后缀，每次比较的复杂度时$O(n)$，最终复杂度是$O(n^2\log n)$</p><h4 id="方法2：-二分lcp-Hash"><a href="#方法2：-二分lcp-Hash" class="headerlink" title="方法2： 二分lcp+Hash"></a>方法2： 二分lcp+Hash</h4><p>​        对于任意两个后缀$suf(i)和suf(j)$，我们利用二分和哈希得到他们的lcp，比较他们两个的大小只需要比较lcp后的第一个位置即可。这样的复杂度是$O(\log n)$，总复杂度是$O(n\log^2n)$</p><h4 id="方法3：-倍增做法"><a href="#方法3：-倍增做法" class="headerlink" title="方法3： 倍增做法"></a>方法3： 倍增做法</h4><p>​        我们定义$sa[i]$表示排名为i的后缀的开始位置，$rank[i]$表示后缀$suf(i)$的排名。显然有如下结论：$sa[rank[i]] = i$，$rank[sa[i]] = i$，即sa和rank互为反函数</p><p>​        定义$sub[i][k]$表示str从i开始长度为k的子串(若长度超过了str的范围，则之后的都视为空)。$rank[i][k]$表示$sub[i][k]$在所有长度为$2^k$的子串中的排名，$sa[i][k]$表示所有长度为$2^k$的子串中，排名为i的子串是从哪里开始的</p><p>​        step1：首先求出所有$sub[1][0],sub[2][0],……,sub[n][0]$的字典排序</p><p>​        step2：求出所有$sub[1][1],sub[2][1],……,sub[n][1]$的字典排序</p><p>​        …… </p><p>​        当子串长度$2^k&gt;n$时，子串的排序就是我的后缀排序（一共做$\lceil \log k\rceil$次）</p><p>​        那么我们如何快速的求出$sub[1][k+1],sub[2][k+1],……,sub[n][k+1]$的字典排序呢？利用$sub[1][k],sub[2][k],……,sub[n][k]$的结果</p><p>​        对于$sub[i][k+1]和sub[j][k+1]$我们可以分成两部分来比较，第一部分是$sub[i][k]和sub[j][k]$，第二部分是$sub[i+2^k-1][k]和sub[j+2^k-1][k]$</p><p>​        如果两者第一部分就不同，那么我们根据$rank[i][k]和rank[j][k]$就可以判断两者的大小</p><p>​        如果第一部分相同，就根据$rank[i+2^k-1][k]和rank[j+2^k-1][k]$比较两者的大小</p><p>​        如果把这两部分看成是pair的话，就是比较$\{rank[i][k],rank[i+2^k-1][k] \}和\{rank[j[k],rank[j+2^k-1][k] \}$，当然这里有一个显而易见的优化，我的$rank[i][k+1]$和$sa[i][k+1]$只和$rank[i][k]和rank[j][k]$有关，所以可以使用滚动数组</p><p>​        这里我们利用基数排序来比较他们的大小，对于基数排序来说，需要先比较second再比较first</p><p>​        于是有如下代码:</p><p>先对second进行排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; ++i) ++cnt[rk[id[i] + w]];<span class="hljs-comment">//w代表2^k,id[i]表示我之前的sa[i]</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (i = n; i &gt;= <span class="hljs-number">1</span>; --i) sa[cnt[rk[id[i] + w]]--] = id[i];<span class="hljs-comment">//注意这里需要倒序</span><br></code></pre></td></tr></table></figure><p>再对first进行排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; ++i) ++cnt[rk[id[i]]];<span class="hljs-comment">//同理这里的id[i]就是我之前的sa[i]</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= m; ++i) cnt[i] += cnt[i - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (i = n; i &gt;= <span class="hljs-number">1</span>; --i) sa[cnt[rk[id[i]]]--] = id[i];<span class="hljs-comment">//同理这里也需要倒序</span><br></code></pre></td></tr></table></figure><p>最后把我的结果转移到新的rank中，对于排序后相邻的两个sub，如果他们的first和second都相等，那他们更新后的rank也相等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (p = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br><span class="hljs-keyword">if</span> (oldrk[sa[i]] == oldrk[sa[i - <span class="hljs-number">1</span>]] &amp;&amp;<span class="hljs-comment">//这里的oldrk[i]表示我之前的rank[i]</span><br>oldrk[sa[i] + w] == oldrk[sa[i - <span class="hljs-number">1</span>] + w]) &#123;<br>        rk[sa[i]] = p;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       rk[sa[i]] = ++p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="倍增算法的一点优化"><a href="#倍增算法的一点优化" class="headerlink" title="倍增算法的一点优化"></a>倍增算法的一点优化</h4><h5 id="1-第二关键字无需基数排序"><a href="#1-第二关键字无需基数排序" class="headerlink" title="1.第二关键字无需基数排序"></a>1.第二关键字无需基数排序</h5><p>​    第二关键字排序的实质，其实就是把对于$sa[i]+w&gt;n$的后缀，放到id的头部，因为前后两次唯一会产生变化次序的位置，就是我满足$sa[i]+w&gt;n$的所有i。在$len=w/2$时，他们的第二关键字&gt;0，在$len=w$时，他们的第二关键字=0。</p><p>​    因此得到如下的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - w + <span class="hljs-number">1</span>; i &lt;= n; i++) id[++cur] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>  <span class="hljs-keyword">if</span> (sa[i] &gt; w) id[++cur] = sa[i] - w;<br></code></pre></td></tr></table></figure><h5 id="2-值域的优化"><a href="#2-值域的优化" class="headerlink" title="2.值域的优化"></a>2.值域的优化</h5><p>​    一开始我们利用的是ascall码作为值域，事实上值域不需要这么大，利用我们最后合并时得到的不同种类p即可</p><h5 id="3-若排名不同可以直接输出后缀数组"><a href="#3-若排名不同可以直接输出后缀数组" class="headerlink" title="3. 若排名不同可以直接输出后缀数组"></a>3. 若排名不同可以直接输出后缀数组</h5><p>​    当种类(p) = 字符串的长度(n)时，后缀数组其实已经排好了，直接输出即可</p><p>所以综上优化，得到我的后缀数组的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cnt[rk[i] = s[i]]++;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) cnt[i] += cnt[i - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) sa[cnt[rk[i]]--] = i;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = <span class="hljs-number">1</span>;; w &lt;&lt;= <span class="hljs-number">1</span>, m = p) &#123;  <span class="hljs-comment">// m = p 即为值域优化</span><br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - w + <span class="hljs-number">1</span>; i &lt;= n; i++) id[++cur] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>      <span class="hljs-keyword">if</span> (sa[i] &gt; w) id[++cur] = sa[i] - w;<br><br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) cnt[rk[i]]++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) cnt[i] += cnt[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) sa[cnt[rk[id[i]]]--] = id[i];<br><br>    p = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memcpy</span>(oldrk, rk, <span class="hljs-built_in">sizeof</span>(oldrk));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>      <span class="hljs-keyword">if</span> (oldrk[sa[i]] == oldrk[sa[i - <span class="hljs-number">1</span>]] &amp;&amp;<br>          oldrk[sa[i] + w] == oldrk[sa[i - <span class="hljs-number">1</span>] + w])<br>        rk[sa[i]] = p;<br>      <span class="hljs-keyword">else</span><br>        rk[sa[i]] = ++p;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (p == n) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// p = n 时无需再排序</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-利用后缀数组，得到两个后缀的lcp"><a href="#2-利用后缀数组，得到两个后缀的lcp" class="headerlink" title="2. 利用后缀数组，得到两个后缀的lcp"></a>2. 利用后缀数组，得到两个后缀的lcp</h3><p>我们定义$height[i]=lcp(suf_{sa[i-1]},suf_{sa[i]})$值得注意的是，这里的两个后缀的后缀数组sa中相邻的两个</p><p>那如果我想得到任意的两个后缀的lcp呢？有结论</p><h5 id="lcp-suf-i-suf-j-min-k-l-1-r-height-k-，其中-l-sa-suf-i-r-sa-suf-j-，这里可以维护一个RMQ实现"><a href="#lcp-suf-i-suf-j-min-k-l-1-r-height-k-，其中-l-sa-suf-i-r-sa-suf-j-，这里可以维护一个RMQ实现" class="headerlink" title="$lcp(suf_i,suf_j)=min_{k=l+1}^{r}(height[k])$，其中$l=sa[suf_i],r=sa[suf_j]$，这里可以维护一个RMQ实现"></a>$lcp(suf_i,suf_j)=min_{k=l+1}^{r}(height[k])$，其中$l=sa[suf_i],r=sa[suf_j]$，这里可以维护一个RMQ实现</h5><p>证明：</p><p>​    首先证明对于$s1&lt;s2&lt;s3有lcp(s1,s3)=min(lcp(s1,s2),lcp(s2,s3))$</p><p>以下图中的黑色代表$lcp(s_1,s_2)$红色代表$lcp(s_2,s_3)$</p><p><img src="/2024/06/09/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84SA/case1.jpg" alt></p><p>对于这种情况显然成立，假设说我的$lcp(s_1,s_3)&gt;lcp(s_2,s_3)$，则有$s_3[i+1]\ne s_2[i+1],s_3[i+1]=s_1[i+1]\rightarrow s_1[i+1] \ne s_2[i+1]$，与我的假设矛盾</p><p><img src="/2024/06/09/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84SA/case2.jpg" alt></p><p>同理以上case1的情况，也能得到结论成立</p><p><img src="/2024/06/09/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84SA/case3.jpg" alt></p><p>当我三个长度都相等的时候，如果说此时$lcp(s_1,s_3)&gt;lcp(s_2,s_3)$那么，就有$b\ne c \land b\ne a$，那么此时我的$s_1,s_2,s_3$的排序就不是这样的，应该是$s_1,s_3,s_2,即s_2不会在s_1,s_3之间$，故假设矛盾。</p><p>综上我们的结论成立。</p><p>​    之后再从s1,s3之间找出所有的$s_i$都满足$lcp(s1,s3)=min(lcp(s_1,s_i),lcp(s_i,s_3))$，即可得证。(不严格的证明)</p><p>​    </p><p>那么如何快速求解height，有结论</p><h5 id="height-l-ge-height-r-1-其中l-rank-i-r-rank-i-1"><a href="#height-l-ge-height-r-1-其中l-rank-i-r-rank-i-1" class="headerlink" title="$height[l]\ge height[r]-1,其中l=rank[i],r=rank[i-1]$"></a>$height[l]\ge height[r]-1,其中l=rank[i],r=rank[i-1]$</h5><p>不会证明，记住就行</p><p>有如下代码，求height</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>  <span class="hljs-keyword">if</span> (rk[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-keyword">if</span> (k) --k;<br>  <span class="hljs-keyword">while</span> (s[i + k] == s[sa[rk[i] - <span class="hljs-number">1</span>] + k]) ++k;<br>  height[rk[i]] = k;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        </p><p>​        </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>后缀自动机(SAM)</title>
    <link href="/2024/06/07/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/"/>
    <url>/2024/06/07/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/</url>
    
    <content type="html"><![CDATA[<h1 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h1><h2 id="1-后缀自动机实现的功能"><a href="#1-后缀自动机实现的功能" class="headerlink" title="1. 后缀自动机实现的功能"></a>1. 后缀自动机实现的功能</h2><p>给定一个string,例如为<strong><em>“aabab”</em></strong>他有后缀<strong><em>b</em></strong>, <strong><em>ab</em></strong>, <strong><em>bab</em></strong>等，需要把他们构建在同一个trie上，如果暴力地构建得到以下trie结构</p><p><img src="/2024/06/07/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/tirepre.png" alt="tirepre.png"></p><p>如上图所示，但是我们会发现一个问题，节点个数有 $O(n^2)$个，但是我们可以发现</p><p><img src="/2024/06/07/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/tire重合.png" alt="tire重合.png"></p><p>两个红色矩形内代表的后缀子串都是bab，因此可以化简为以下形式</p><p><img src="/2024/06/07/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/tireafter.png" alt="tireafter.png"></p><p>因此，我们想要找到一个节点数和边数尽可能少的DAG</p><h2 id="2-后缀自动机的构建"><a href="#2-后缀自动机的构建" class="headerlink" title="2. 后缀自动机的构建"></a>2. 后缀自动机的构建</h2><p>定义：我们定义endpos(a)表示a子串在整个string中出现的位置（只记录最右的位置）</p><p>例如对于string = “abbab”,下标对应12345 我的endpos(“ab”) = {2，5}，endpos(“bab”) = {5}</p><p>现在可以证明三个结论</p><h3 id="（1）如果两个子串的endpos相同，则其中一个子串一定是另一个的后缀"><a href="#（1）如果两个子串的endpos相同，则其中一个子串一定是另一个的后缀" class="headerlink" title="（1）如果两个子串的endpos相同，则其中一个子串一定是另一个的后缀"></a>（1）如果两个子串的endpos相同，则其中一个子串一定是另一个的后缀</h3><p>对于两个子串s,t，要求len(s) $\le$ len(t)，那么如果我的s不是t的后缀，则会出现以下的情况</p><p><img src="/2024/06/07/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/推论1.png" alt="推论1.png"></p><p>因为s不是t的后缀所以一定存在一个位置（绿色的位置）使得t[i]$\neq$s[i]</p><p>但是既然我的s与t的endpos相同，放在整个string串上来看t[i - x] = s[i - x]，即绿色位置必然是相等的，与前提矛盾，所以反证法成立</p><h3 id="（2）对于任意两个子串t，p满足len-t-le-len-s-要么endpos-t-subseteq-endpos-s-要么endpos-t-cap-endpos-s-emptyset"><a href="#（2）对于任意两个子串t，p满足len-t-le-len-s-要么endpos-t-subseteq-endpos-s-要么endpos-t-cap-endpos-s-emptyset" class="headerlink" title="（2）对于任意两个子串t，p满足len(t)$\le$len(s),要么endpos(t)$\subseteq$endpos(s),要么endpos(t)$\cap$endpos(s) = $\emptyset$"></a>（2）对于任意两个子串t，p满足len(t)$\le$len(s),要么endpos(t)$\subseteq$endpos(s),要么endpos(t)$\cap$endpos(s) = $\emptyset$</h3><p>分为两种情况来讨论：</p><p>case1：t是s的后缀，则显然有endpos(t)$\subseteq$endpos(s)</p><p>case2 ：t不是s的后缀，根据我的推论1，两个子串的endpos必然不同，即endpos(t)$\cap$endpos(s) = $\emptyset$</p><h3 id="（3）对于endpos相同的子串，可以视作一个等价类，满足子串长度连续，且均为后缀"><a href="#（3）对于endpos相同的子串，可以视作一个等价类，满足子串长度连续，且均为后缀" class="headerlink" title="（3）对于endpos相同的子串，可以视作一个等价类，满足子串长度连续，且均为后缀"></a>（3）对于endpos相同的子串，可以视作一个等价类，满足子串长度连续，且均为后缀</h3><p>例如对于<strong><em>“aabab”</em></strong>，endpos=4的子串有<strong><em>aaba,aba,ba,a</em></strong>可以发现长度连续，且后一个为前一个的后缀</p><p>显然有长度覆盖的区间是连续的</p><p>对于后缀结论，通过推论2，可得：endpos(t)$\subseteq$endpos(s)$\Rightarrow$t是s的后缀</p><h3 id="（4）endpos的等价类个数有-O-n-个"><a href="#（4）endpos的等价类个数有-O-n-个" class="headerlink" title="（4）endpos的等价类个数有$O(n)$个"></a>（4）endpos的等价类个数有$O(n)$个</h3><p>对于一个类，我一定能从中找到一个长度最长的字符串s，此时我在s前加上一个字符，记作newstr</p><p>那么此时我的newstr一定不存在我的endpos=endpos(s)所代表的string集合中，因此得到了一个新的等价类，但是我的endpos(newstr)$\subset$endpos(s)</p><p>如果我在s前加上两个不相同的字符（记作str2）呢？显然此时有endpos(str2)$\cap$endpos(newstr)=$\emptyset$，因此我的str2和newstr分别代表的等价类可以视作endpos(s)的划分，不会超过原有集合的大小，因此所有的等价类加在一起不会超过$2|endpos(s)|$个，因此可以视作是$O(n)$的</p><p>此时给出如下定义：若集合B是我集合A的一个划分，则称A是B的父亲</p><h3 id="（5）一个等价类a，称最长的子串为len-a-，最短的子串为minlen-a-，设fa-a-表示类a的父亲，有len-fa-a-1-minlen-a"><a href="#（5）一个等价类a，称最长的子串为len-a-，最短的子串为minlen-a-，设fa-a-表示类a的父亲，有len-fa-a-1-minlen-a" class="headerlink" title="（5）一个等价类a，称最长的子串为len(a)，最短的子串为minlen(a)，设fa(a)表示类a的父亲，有len(fa(a)) + 1 = minlen(a)"></a>（5）一个等价类a，称最长的子串为len(a)，最短的子串为minlen(a)，设fa(a)表示类a的父亲，有len(fa(a)) + 1 = minlen(a)</h3><p>这是显然的，因为我在endpos(a)的最长str前加上一个字符,得到的endpos记作b，根据推论4，fa(b) = a，且此时的c + strZ一定是集合b中最短的str</p><p>此时我们可以尝试给出<strong><em>aababa</em></strong>的后缀自动机形式了(图中节点旁边写的str代表该endpos集合包含的最长str)</p><p><img src="/2024/06/07/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/推论5.png" alt="推论5.png"></p><p>后缀自动机的最终形态并不是如此，还需要加上边，使得从源点出发到节点i的任意一条路径形成的字符串都是属于i的等价类</p><p>图中黑色的线代表的是parent tree的边，蓝色的线是后缀自动机的边</p><p><img src="/2024/06/07/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA-SAM/建好的SAM.png" alt="建好的SAM.png"></p><p>我们可以理解为沿着parent tree的边跑，相当于在字符串前面添加字符，而沿着后缀自动机的边跑，相当于在字符串后面添加字符</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>article title</title>
    <link href="/2024/06/06/article-title/"/>
    <url>/2024/06/06/article-title/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>post title</title>
    <link href="/2024/06/05/post-title/"/>
    <url>/2024/06/05/post-title/</url>
    
    <content type="html"><![CDATA[<h1 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h1><h3 id="1-后缀自动机实现的功能"><a href="#1-后缀自动机实现的功能" class="headerlink" title="1. 后缀自动机实现的功能"></a>1. 后缀自动机实现的功能</h3><p>给定一个string,例如为<strong><em>“abbaba”</em></strong>他有后缀<strong><em>a</em></strong>, <strong><em>ba</em></strong>,, <strong><em>aba</em></strong>等，需要把他们构建在同一个trie上，如果暴力地构建得到以下</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/06/05/hello-world/"/>
    <url>/2024/06/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
