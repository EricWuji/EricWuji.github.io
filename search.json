[{"title":"重链剖分","path":"/2024/07/05/重链剖分/","content":"重链剖分1.重链剖分的板子1234567891011121314151617181920void dfsFir(int u, int pre) &#123; siz[u] = 1; for (auto &amp;[v, w] : edge[u]) &#123; if (v == pre) continue; dep[v] = dep[u] + 1; dfsFir(v, u); val[v] = w; siz[u] += siz[v], fa[v] = u; if (siz[son[u]] &lt; siz[v]) son[u] = v; &#125;&#125;//其中这里的seg[i]表示线段树上的i位置对应在树上的位置void dfsSec(int u, int tp) &#123; dfn[u] = ++timer, seg[timer] = u, top[u] = tp; if (son[u]) dfsSec(son[u], tp); for (auto &amp;[v, w] : edge[u]) &#123; if (v == fa[u] || v == son[u]) continue; dfsSec(v, v); &#125;&#125; 2.把边权转移到点权上原题链接 解：对于$(u,v)$这条边，其中边权为$w$，我们该如何把这条边转移到点权上呢？只需要让深度大的点存这个边权即可。 例如在上图中，假设以1为根节点，则$(1,2)$的这条边权转换为2的点权；同理$(3,4)$的边权也可以转换为4的点权 那么我们在维护边权信息的时候与点权时有什么不同呢？ 1.对于$l$到$r$路径上的边权都$+val$的情况，我们可以把他转换为$l$到$r$路径上的点权都$+val$，之后对于$lca(l,r)$节点$-val$。 为什么最后要减去？因为$lca(l,r)$代表的边权是$(fa[lca],lca)$，并不在$l$到$r$的路径上。 2.对于查询$l$到$r$路径上的边权和，与1同理，我要的答案就是$l$到$r$的点权和，再减去$lca(l,r)$的点权"},{"title":"数论基础","path":"/2024/07/03/数论基础/","content":"数论基础1.拓展欧几里得拓展欧几里得就是求形如$ax+by=\\gcd(a,b)$的整数解的一组特解 123456//ax + by = d//这个模板中的d = gcd(a, b) 顺便也求出来了inline void exgcd(int a, int b, int &amp;d, int &amp;x, int &amp;y) &#123; if (!b) d = a, x = 1, y = 0; else exgcd(b, a % b, d, y, x), y -= x * (a / b);&#125; 2.裴蜀定理对于一个不定方程$ax+by=c$，有整数解的充要条件是$c\\mid \\gcd(a,b)$ 更进一步，有对于不定方程$a_1x_1+a_2x_1+a_3x_3+…+a_n x_n=d$，有整数解的充要条件是$d\\mid \\gcd(a_1,a_2,…a_n)$ 3.线性筛素数代码中$isPrime[i]$表示i是否是质数，$primes[i]$表示第i小的质数是多少 123456789memset(isPrime, 1, sizeof(isPrime));\tfor (int i = 2;i &lt;= N;i++) &#123;\tif (isPrime[i]) primes[++cnt] = i; for (int j = 1;j &lt;= cnt &amp;&amp; i * primes[j] &lt;= N;j++) &#123; isPrime[i * primes[j]] = false; if (i % primes[j] == 0) break; &#125;&#125; 4.求乘法逆元1.求单个整数的乘法逆元一般来说我们要求的mod都是一个质数，所以我们可以直接利用$a^{p-2} \\equiv 1\\pmod p$ 1234567int qpow(int a, int b) &#123; int ans = 1; for (;b;b &gt;&gt;= 1, a = a * a % mod) if (a &amp; 1) ans = a * ans % mod; return ans;&#125;int inv_x = qpow(x, mod - 2); 2.求解一个线性同余方程求解形如$ax \\equiv b \\pmod p$的方程 解：$ax \\equiv b \\pmod p \\Rightarrow ax-b=py \\Rightarrow ax-py=b \\Rightarrow ax+py’=b$ 其实就是求解$ax+py=b$这样一个不定方程，用拓展欧几里得实现 3.线性求解n个数的逆元：给你n个整数让你求出他们的逆元我们设$s[i]=\\prod_{i=1}^na[i]$，那么有$s_{i-1}a_i=s_i$，两边同时除$s_{i-1}s_i$，得$a_is_i^{-1}=s_{i-1}^{-1}$，即$a_iinv[s_i]=inv[s_{i-1}]$， 故我们可以线性求出所有的$inv[s[i]]$，同样的我们可以把方程变为$a_i^{-1}=s_{i-1}s_i^{-1}$，即$inv[a_i]=s_{i-1}inv[s_i]$，故我们也可以线性的求出所有$a_i$的逆元 4.线性求解所有$[1,n]$的逆元"},{"title":"树型DP","path":"/2024/06/28/树型DP/","content":"树型DP选择节点类的题目例1. 没有上司的舞会原题链接 解：我们设$dp[i][0/1]$分别表示 选/不选 第$i$个人的最大快乐值，设当前节点为u，u的儿子为v，$a[i]$表示i的快乐值 那么，我们可以列出他的转移方程： $\\begin{cases} \\begin{aligned} dp[u][0] &amp;=\\sum \\max{(dp[v][0],dp[v][1])} \\\\ dp[u][1] &amp;=\\sum \\max{(dp[v][0],dp[v][1])+a[u]} \\end{aligned} \\end{cases}$ 我们利用dfs的方式即可实现功能 12345678910111213141516171819202122int dfs(int u, int ok) &#123; if (dp[u][ok] != LONG_LONG_MIN) &#123; return dp[u][ok]; &#125; if (!ok) &#123; int ans = 0; for (auto &amp;it : edge[u]) &#123; ans += dfs(it, 1); &#125; return dp[u][ok] = ans; &#125; else &#123; int ans = 0; for (auto &amp;it : edge[u]) &#123; ans += dfs(it, 1); &#125; int ans2 = r[u]; for (auto &amp;it : edge[u]) &#123; ans2 += dfs(it, 0); &#125; return dp[u][ok] = max(ans, ans2); &#125;&#125; 树上背包问题例1. 有线电视网原题链接 解：我们设$dp[i][j]$表示以i为根的子树中，满足j个人需求的最大利润。其中第$i$条边的成本为$c[i]$，第i个人愿意交的钱为$a[i]$，$cost[i][j]$表示从i到j的成本 那么我们怎么去求$dp[u][j]$呢？首先我们肯定要遍历u的所有儿子v，但是对于不同的v，我们可以选择不同的$dp[v][j’]$，来使得我的$dp[u][j]$最大。很显然，任意的$dp[v][j’]$是已知的，所以这道题就变成了一道背包问题，即已知背包容量为j，我有若干个物品，价值为$dp[v][j’]$，重量为$j’$。 1234567891011void dfs(int u) &#123; if (leaf[u]) return ; for (auto &amp;it : edge[u]) dfs(it), siz[u] += siz[it]; for (auto &amp;it : edge[u]) &#123; for (int j = siz[u];j &gt;= 1;j--) &#123; for (int k = 1;k &lt;= siz[u];k++) &#123; dp[u][j] = max(dp[u][j], dp[u][j - k] + dp[it][k] - cost[u][it]); &#125; &#125; &#125;&#125; 为什么以上代码需要我记录$siz[u]$，因为对于以i为根的子树，他最多也就能满足$siz[i]$个人 例2. 树上染色原题链接 解：我们设$dp[i][j]$表示以i为根的子树中染了j个黑色的点，对答案的贡献。一共要涂m个黑点 由此我们可以列出状态转移方程，对于从u到v的路径 ，长度为w，有$dp[u][j]=\\max(\\sum dp[v][j’]+tot*w)$ 其中我的tot表示，w对答案的贡献，其中$tot=j(m-j)+(siz[v]-j)(n-siz[v]+j-m)$ 1234567891011121314151617void dfs(int u, int pre) &#123; siz[u] = 1, dp[u][0] = dp[u][1] = 0; for (int i = head[u];i;i = e[i].nxt) &#123; int v = e[i].to, weight = e[i].weight; if (v == pre) continue; dfs(v, u); siz[u] += siz[v]; for (int j = min(m, siz[u]);j &gt;= 0;j--) &#123; for (int k = 0;k &lt;= min(j, siz[v]);k++) &#123; if (dp[v][k] == -1 || dp[u][j - k] == -1) continue; int tot = k * (m - k) + (siz[v] - k) * (n - m - siz[v] + k); dp[u][j] = max(dp[u][j], dp[u][j - k] + dp[v][k] + tot * weight); &#125; &#125; &#125;&#125; 换根DP例1. STA-station原题链接 解：设$dp[i]$表示以i为根的时候，深度和是多少。 对于换根DP来说，一般都需要dfs两遍，例如在本题中，第一次dfs，能够求出以1为根的深度和，即$dp[1]$ 第二次dfs时，从以u为根到以v为根，如下图所示： 我们可以看到对于v的子树，他的dep都是-1，其余的dep都是+1 所以$dp[v]=dp[u]-(n-siz[v])+siz[v]=dp[u]+2*siz[v]-n$ 12345678910111213141516void dfs(int u, int pre) &#123; for (auto &amp;it : edge[u]) &#123; if (it == pre) continue; dep[it] = dep[u] + 1; dfs(it, u); siz[u] += siz[it]; &#125;&#125;void DP(int u, int pre) &#123; for (auto &amp;it : edge[u]) &#123; if (it == pre) continue; dp[it] = dp[u] + (n - siz[it]) - siz[it]; if (dp[it] &gt; ans) ans = dp[it], idx = it; DP(it, u); &#125;&#125;"},{"title":"区间DP","path":"/2024/06/26/区间DP/","content":"区间DP例1. 关路灯原题连接 大意：给你初始位置$x_0$以及每个路灯的位置$x_i$和功率$p_i$，你的速度为1$m/s$，问关闭所有路灯后，最小的能耗 解： 规定$sum_k=\\sum_{i=1}^{k}p_i$ 设$dp[i][j][0/1]$表示关闭$[i,j]$的所有路灯后，你停留在i位置(0)或者j位置(1)的最小能耗 那么对于$dp[i][j][0/1]$有两种转移策略： ​ 第一种策略：$dp[i][j]从dp[i + 1][j]$转移过来； 第二种策略：$dp[i][j]从dp[i][j+1]$转移过来 所以对于$dp[i][j][0]$，他只会从$dp[i+1][j][0],dp[i+1][j][1]$转移过来： ​ 如果他从$dp[i+1][j][0]$转移过来，有：$dp[i][j][0]=dp[i+1][j][0]+(x_{i+1}-x_i)*(sum_{n}+sum_i-sum_j)$ ​ 如果他从$dp[i+1][j][1]$转移过来：有：$dp[i][j][0]=dp[i+1][j][1]+(x_j-x_i)*(sum_{n}+sum_i-sum_j)$ 解释一下$sum_{n}+sum_i-sum_j$，因为我最后要站在i位置上，所以位置$[i+1,j]$的灯都是关上的，他们的功率和是$sum_j-sum_{i}$ 所以剩下的在工作的功率就是$sum_n-sum_j+sum_i$ 同理对于$dp[i][j][1]$，他只会从$dp[i][j-1][0],dp[i][j-1][1]$转移过来： ​ 如果他从$dp[i][j-1][0]$转移过来，有：$dp[i][j][1]=dp[i][j-1][0]+(x_j-x_i)*(sum_n-sum_{j-1}+sum_{i-1})$ ​ 如果他从$dp[i][j-1][1]$转移过来，有：$dp[i][j][1]=dp[i][j-1][1]+(x_j-x_{j-1})*(sum_n-sum_{j-1}+sum_{i-1})$ 解释一下$sum_n-sum_{j-1}+sum_{i-1}$，因为我最后要站在j位置上，所以位置$[i,j-1]$的灯都是关上的，他们的功率和是$sum_{j-1}-sum_{i-1}$，所以剩下的在工作的灯的总功率是$sum_n-sum_{j-1}+sum_{i-1}$ 关于赋初值的问题，我们只需要吧初始位置$x_0$的dp设置为0即可，即$dp[x_0][x_0][0] = dp[x_0][x_0][1]=0$ 其余的位置我可以不去管他，因为他是从i出发的 例2. 涂色原题连接 大意：给你一个长度为n的木板，涂成给定的颜色状态，其中对于相同的位置，先刷上的颜色会被后刷上的颜色覆盖，问最小的涂色次数 解： 我们设$dp[i][j]$表示把位置$[i,j]$涂成目标状态的最小涂色次数 那么，对于任意的i，有$dp[i][i]=1$，一个点，最小的次数一定是1 对于$i e j \\land s[i]==s[j]$，那么$dp[i][j]=min(dp[i][j-1],dp[i+1][j])$ 为什么？对于$dp[i][j-1]$，我在涂色$[i,j-1]$时，是可以把$s[i]$也考虑进来的($s[i]==s[j]$)，也就是说我可以先把$[i,j]$全部涂色成$s[i]$的颜色，之后再在$[i,j-1]$上找最优秀的涂色方式。 问题：把整个区间涂色之后不会导致我的$dp[i][j-1]$不成立吗？不会。因为先涂色的会被覆盖，刷的范围越大，只会对结果更有利 对于$i e j \\land s[i] e s[j]$，那么$dp[i][j] = \\max_{k=i}^{j}{dp[i][k]+dp[k+1][j]}$，就是两个区间的和 问题1：两个区间不会出现两者中间有连续一段相同的颜色，可以一步到位吗？会出现，但是我的k会枚举到他们分别在两个区域中的情况 问题2：会不会出现先把$[i,j]$都刷成某一种颜色，再进行涂色，使得方案更优？会出现，但是因为这里$s[i] e s[j]$所以当我的$k=i||k=j-1$时，实际上我的$dp[i][k]+dp[k+1][j]$就是问题2中描述的情况($dp[i][i] = dp[j][j]=1$)"},{"title":"后缀的一些运用1","path":"/2024/06/10/后缀的一些运用1/","content":"后缀数组的一些运用和小结论11.最长重复子串原题地址 题目大意：给你一个字符串，让你求出至少出现两次的最长子串 解：这是一道板子题，所谓至少出现两次，其实就是我的$hegiht[i]$，即我的$lcp(s_1,s_2)$。所以我只要求出所有的height取最大值即可 时间复杂度$O(n\\log n)$ 2.字符加密原题地址 解：看到环形字符串，下意识就会把它复制一份拼上。之后直接跑一个SA，收集答案时，对于$sa[i]&gt;n$的情况，我们不做处理，因为他不在我要的$[1,n]$的区间内。 3.New Distinct Substrings原题地址 题目大意：给你一个字符串问有几个本质不同的子串，即若子串形态相同，位置不同，算同一种 解：我们先考虑在sa排序上相邻的两个子串，可以发现$sa[i-1]$可以代表$len(sa[i-1])$种子串，同理$sa[i]$可以代表$len(sa[i])$种子串，他们之间有$len(lcp(sa[i-1],sa[i]))= height[i]$，也就意味着他们有$height[i]$个子串是本质相同的。故$sa[i]和sa[i-1]$对答案的贡献为$len(sa[i-1])+len(sa[i])-height[i]$，对于整个字符串一共有后缀$\\frac{n*(n+1)}{2}$个，也就是$\\sum_{i=1}^nlen(sa[i])$ 所以最后的答案为$\\frac{n*(n+1)}{2}-\\sum_{i=1}^n height[i]$ 4.NSUBSTR - Substrings原题地址 题目大意：给你一个字符串，问长度为$[1,n]$的子串最多出现了多少次 解：首先我们通过SA可以得到SA中相邻两个字符串的lcp，对于任意两个字符串，有$lcp(s_1,s_2)=\\min_{k=i}^j(height[k])$，因此对于长度为L的一个子串，它出现的最多次数，就是在SA上连续$height[i]\\ge L$的最长长度，因为他们的lcp是连续的。 如何求出这个长度呢？使用单调栈，先从左往右扫一遍，得到满足$height[i]\\ge L$的最左端点位置，再从右往左扫一遍，得到满足$height[i]\\ge L$的最右端位置，最后枚举每个位置计算$len[i]=right[i]-left[i]+2$（包括左右端点） 最后算答案的时候，需要利用长度长的出现次数来更新，长度短的出现次数，因为它可能没有被统计到 单调栈代码如下： 123456789101112131415161718192021222324struct mono_stack &#123;\tint stk[MAXN], top;\tvoid push(int x) &#123; while (top &gt; 1 &amp;&amp; height[stk[top]] &gt;= height[x]) -- top; stk[++top] = x;\t&#125;\tint back() &#123; return stk[top - 1];\t&#125;\tvoid clear() &#123; top = 0;\t&#125;&#125;;mono_stack stk;int ll[MAXN], rr[MAXN];void solve() &#123;\tstk.push(0);\tfor (int i = 1;i &lt;= n;i++)\tstk.push(i), ll[i] = stk.back() + 1;\tstk.clear(), stk.push(n + 1);\tfor (int i = n;i &gt;= 1;i--) stk.push(i), rr[i] = stk.back() - 1;\tfor (int i = 1;i &lt;= n;i++) times[height[i]] = max(times[height[i]], rr[i] - ll[i] + 2);\ttimes[n + 1] = 1;\tfor (int i = n;i &gt;= 1;i--) times[i] = max(times[i], times[i + 1]);&#125;"},{"title":"后缀数组SA","path":"/2024/06/09/后缀数组SA/","content":"后缀数组1. 后缀数组用来解决什么问题​ 对于一个str，我们设$suf(x)$表示str从x位置开始的后缀，例如str=“abababa“,则$suf(3)=ababa$ ​ 另外我们定义$lcp(suf_i,suf_j)$表示i和j两个字符串的最长公共前缀 ​ 要求我们把后缀$suf(1),suf(2),……,suf(n)$按照字典序从小到大排序好，得到一个后缀数组 2. 如何得到后缀数组方法1： 暴力sort​ 对于一个str，我们有n个后缀，利用sort暴力排序，一共有n个后缀，每次比较的复杂度时$O(n)$，最终复杂度是$O(n^2\\log n)$ 方法2： 二分lcp+Hash​ 对于任意两个后缀$suf(i)和suf(j)$，我们利用二分和哈希得到他们的lcp，比较他们两个的大小只需要比较lcp后的第一个位置即可。这样的复杂度是$O(\\log n)$，总复杂度是$O(n\\log^2n)$ 方法3： 倍增做法​ 我们定义$sa[i]$表示排名为i的后缀的开始位置，$rank[i]$表示后缀$suf(i)$的排名。显然有如下结论：$sa[rank[i]] = i$，$rank[sa[i]] = i$，即sa和rank互为反函数 ​ 定义$sub[i][k]$表示str从i开始长度为k的子串(若长度超过了str的范围，则之后的都视为空)。$rank[i][k]$表示$sub[i][k]$在所有长度为$2^k$的子串中的排名，$sa[i][k]$表示所有长度为$2^k$的子串中，排名为i的子串是从哪里开始的 ​ step1：首先求出所有$sub[1][0],sub[2][0],……,sub[n][0]$的字典排序 ​ step2：求出所有$sub[1][1],sub[2][1],……,sub[n][1]$的字典排序 ​ …… ​ 当子串长度$2^k&gt;n$时，子串的排序就是我的后缀排序（一共做$\\lceil \\log k\\rceil$次） ​ 那么我们如何快速的求出$sub[1][k+1],sub[2][k+1],……,sub[n][k+1]$的字典排序呢？利用$sub[1][k],sub[2][k],……,sub[n][k]$的结果 ​ 对于$sub[i][k+1]和sub[j][k+1]$我们可以分成两部分来比较，第一部分是$sub[i][k]和sub[j][k]$，第二部分是$sub[i+2^k-1][k]和sub[j+2^k-1][k]$ ​ 如果两者第一部分就不同，那么我们根据$rank[i][k]和rank[j][k]$就可以判断两者的大小 ​ 如果第一部分相同，就根据$rank[i+2^k-1][k]和rank[j+2^k-1][k]$比较两者的大小 ​ 如果把这两部分看成是pair的话，就是比较$\\{rank[i][k],rank[i+2^k-1][k] \\}和\\{rank[j[k],rank[j+2^k-1][k] \\}$，当然这里有一个显而易见的优化，我的$rank[i][k+1]$和$sa[i][k+1]$只和$rank[i][k]和rank[j][k]$有关，所以可以使用滚动数组 ​ 这里我们利用基数排序来比较他们的大小，对于基数排序来说，需要先比较second再比较first ​ 于是有如下代码: 先对second进行排序 123for (i = 1; i &lt;= n; ++i) ++cnt[rk[id[i] + w]];\t//w代表2^k,id[i]表示我之前的sa[i]for (i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1];for (i = n; i &gt;= 1; --i) sa[cnt[rk[id[i] + w]]--] = id[i];\t//注意这里需要倒序 再对first进行排序 123for (i = 1; i &lt;= n; ++i) ++cnt[rk[id[i]]];\t//同理这里的id[i]就是我之前的sa[i]for (i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1];for (i = n; i &gt;= 1; --i) sa[cnt[rk[id[i]]]--] = id[i];\t//同理这里也需要倒序 最后把我的结果转移到新的rank中，对于排序后相邻的两个sub，如果他们的first和second都相等，那他们更新后的rank也相等 12345678for (p = 0, i = 1; i &lt;= n; ++i) &#123;\tif (oldrk[sa[i]] == oldrk[sa[i - 1]] &amp;&amp;\t//这里的oldrk[i]表示我之前的rank[i] oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) &#123; rk[sa[i]] = p; &#125; else &#123; rk[sa[i]] = ++p; &#125;&#125; 倍增算法的一点优化1.第二关键字无需基数排序​ 第二关键字排序的实质，其实就是把对于$sa[i]+w&gt;n$的后缀，放到id的头部，因为前后两次唯一会产生变化次序的位置，就是我满足$sa[i]+w&gt;n$的所有i。在$len=w/2$时，他们的第二关键字&gt;0，在$len=w$时，他们的第二关键字=0。 ​ 因此得到如下的代码 1234int cur = 0;for (int i = n - w + 1; i &lt;= n; i++) id[++cur] = i;for (int i = 1; i &lt;= n; i++) if (sa[i] &gt; w) id[++cur] = sa[i] - w; 2.值域的优化​ 一开始我们利用的是ascall码作为值域，事实上值域不需要这么大，利用我们最后合并时得到的不同种类p即可 3. 若排名不同可以直接输出后缀数组​ 当种类(p) = 字符串的长度(n)时，后缀数组其实已经排好了，直接输出即可 所以综上优化，得到我的后缀数组的模板 123456789101112131415161718192021222324252627for (int i = 1; i &lt;= n; i++) cnt[rk[i] = s[i]]++;for (int i = 1; i &lt;= m; i++) cnt[i] += cnt[i - 1];for (int i = n; i &gt;= 1; i--) sa[cnt[rk[i]]--] = i;for (int w = 1;; w &lt;&lt;= 1, m = p) &#123; // m = p 即为值域优化 int cur = 0; for (int i = n - w + 1; i &lt;= n; i++) id[++cur] = i; for (int i = 1; i &lt;= n; i++) if (sa[i] &gt; w) id[++cur] = sa[i] - w; memset(cnt, 0, sizeof(cnt)); for (int i = 1; i &lt;= n; i++) cnt[rk[i]]++; for (int i = 1; i &lt;= m; i++) cnt[i] += cnt[i - 1]; for (int i = n; i &gt;= 1; i--) sa[cnt[rk[id[i]]]--] = id[i]; p = 0; memcpy(oldrk, rk, sizeof(oldrk)); for (int i = 1; i &lt;= n; i++) &#123; if (oldrk[sa[i]] == oldrk[sa[i - 1]] &amp;&amp; oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) rk[sa[i]] = p; else rk[sa[i]] = ++p; &#125; if (p == n) break; // p = n 时无需再排序&#125; 2. 利用后缀数组，得到两个后缀的lcp我们定义$height[i]=lcp(suf_{sa[i-1]},suf_{sa[i]})$值得注意的是，这里的两个后缀的后缀数组sa中相邻的两个 那如果我想得到任意的两个后缀的lcp呢？有结论 $lcp(suf_i,suf_j)=min_{k=l+1}^{r}(height[k])$，其中$l=sa[suf_i],r=sa[suf_j]$，这里可以维护一个RMQ实现证明： ​ 首先证明对于$s1&lt;s2&lt;s3有lcp(s1,s3)=min(lcp(s1,s2),lcp(s2,s3))$ 以下图中的黑色代表$lcp(s_1,s_2)$红色代表$lcp(s_2,s_3)$ 对于这种情况显然成立，假设说我的$lcp(s_1,s_3)&gt;lcp(s_2,s_3)$，则有$s_3[i+1] e s_2[i+1],s_3[i+1]=s_1[i+1]\\rightarrow s_1[i+1] e s_2[i+1]$，与我的假设矛盾 同理以上case1的情况，也能得到结论成立 当我三个长度都相等的时候，如果说此时$lcp(s_1,s_3)&gt;lcp(s_2,s_3)$那么，就有$b e c \\land b e a$，那么此时我的$s_1,s_2,s_3$的排序就不是这样的，应该是$s_1,s_3,s_2,即s_2不会在s_1,s_3之间$，故假设矛盾。 综上我们的结论成立。 ​ 之后再从s1,s3之间找出所有的$s_i$都满足$lcp(s1,s3)=min(lcp(s_1,s_i),lcp(s_i,s_3))$，即可得证。(不严格的证明) ​ 那么如何快速求解height，有结论 $height[l]\\ge height[r]-1,其中l=rank[i],r=rank[i-1]$不会证明，记住就行 有如下代码，求height 123456for (i = 1, k = 0; i &lt;= n; ++i) &#123; if (rk[i] == 0) continue; if (k) --k; while (s[i + k] == s[sa[rk[i] - 1] + k]) ++k; height[rk[i]] = k;&#125; ​ ​"},{"title":"后缀自动机(SAM)","path":"/2024/06/07/后缀自动机-SAM/","content":"后缀自动机1. 后缀自动机实现的功能给定一个string,例如为“aabab”他有后缀b, ab, bab等，需要把他们构建在同一个trie上，如果暴力地构建得到以下trie结构 如上图所示，但是我们会发现一个问题，节点个数有 $O(n^2)$个，但是我们可以发现 两个红色矩形内代表的后缀子串都是bab，因此可以化简为以下形式 因此，我们想要找到一个节点数和边数尽可能少的DAG 2. 后缀自动机的构建定义：我们定义endpos(a)表示a子串在整个string中出现的位置（只记录最右的位置） 例如对于string = “abbab”,下标对应12345 我的endpos(“ab”) = {2，5}，endpos(“bab”) = {5} 现在可以证明三个结论 （1）如果两个子串的endpos相同，则其中一个子串一定是另一个的后缀对于两个子串s,t，要求len(s) $\\le$ len(t)，那么如果我的s不是t的后缀，则会出现以下的情况 因为s不是t的后缀所以一定存在一个位置（绿色的位置）使得t[i]$ eq$s[i] 但是既然我的s与t的endpos相同，放在整个string串上来看t[i - x] = s[i - x]，即绿色位置必然是相等的，与前提矛盾，所以反证法成立 （2）对于任意两个子串t，p满足len(t)$\\le$len(s),要么endpos(t)$\\subseteq$endpos(s),要么endpos(t)$\\cap$endpos(s) = $\\emptyset$分为两种情况来讨论： case1：t是s的后缀，则显然有endpos(t)$\\subseteq$endpos(s) case2 ：t不是s的后缀，根据我的推论1，两个子串的endpos必然不同，即endpos(t)$\\cap$endpos(s) = $\\emptyset$ （3）对于endpos相同的子串，可以视作一个等价类，满足子串长度连续，且均为后缀例如对于“aabab”，endpos=4的子串有aaba,aba,ba,a可以发现长度连续，且后一个为前一个的后缀 显然有长度覆盖的区间是连续的 对于后缀结论，通过推论2，可得：endpos(t)$\\subseteq$endpos(s)$\\Rightarrow$t是s的后缀 （4）endpos的等价类个数有$O(n)$个对于一个类，我一定能从中找到一个长度最长的字符串s，此时我在s前加上一个字符，记作newstr 那么此时我的newstr一定不存在我的endpos=endpos(s)所代表的string集合中，因此得到了一个新的等价类，但是我的endpos(newstr)$\\subset$endpos(s) 如果我在s前加上两个不相同的字符（记作str2）呢？显然此时有endpos(str2)$\\cap$endpos(newstr)=$\\emptyset$，因此我的str2和newstr分别代表的等价类可以视作endpos(s)的划分，不会超过原有集合的大小，因此所有的等价类加在一起不会超过$2|endpos(s)|$个，因此可以视作是$O(n)$的 此时给出如下定义：若集合B是我集合A的一个划分，则称A是B的父亲 （5）一个等价类a，称最长的子串为len(a)，最短的子串为minlen(a)，设fa(a)表示类a的父亲，有len(fa(a)) + 1 = minlen(a)这是显然的，因为我在endpos(a)的最长str前加上一个字符,得到的endpos记作b，根据推论4，fa(b) = a，且此时的c + strZ一定是集合b中最短的str 此时我们可以尝试给出aababa的后缀自动机形式了(图中节点旁边写的str代表该endpos集合包含的最长str) 后缀自动机的最终形态并不是如此，还需要加上边，使得从源点出发到节点i的任意一条路径形成的字符串都是属于i的等价类 图中黑色的线代表的是parent tree的边，蓝色的线是后缀自动机的边 我们可以理解为沿着parent tree的边跑，相当于在字符串前面添加字符，而沿着后缀自动机的边跑，相当于在字符串后面添加字符"},{"title":"post title","path":"/2024/06/05/post-title/","content":"后缀自动机1. 后缀自动机实现的功能给定一个string,例如为“abbaba”他有后缀a, ba,, aba等，需要把他们构建在同一个trie上，如果暴力地构建得到以下"},{"title":"Hello World","path":"/2024/06/05/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]