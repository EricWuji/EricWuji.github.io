[{"title":"后缀数组SA","path":"/2024/06/09/后缀数组SA/","content":"后缀数组1. 后缀数组用来解决什么问题​ 对于一个str，我们设$suf(x)$表示str从x位置开始的后缀，例如str=“abababa“,则$suf(3)=ababa$ ​ 另外我们定义$lcp(suf_i,suf_j)$表示i和j两个字符串的最长公共前缀 ​ 要求我们把后缀$suf(1),suf(2),……,suf(n)$按照字典序从小到大排序好，得到一个后缀数组 2. 如何得到后缀数组方法1： 暴力sort​ 对于一个str，我们有n个后缀，利用sort暴力排序，一共有n个后缀，每次比较的复杂度时$O(n)$，最终复杂度是$O(n^2\\log n)$ 方法2： 二分lcp+Hash​ 对于任意两个后缀$suf(i)和suf(j)$，我们利用二分和哈希得到他们的lcp，比较他们两个的大小只需要比较lcp后的第一个位置即可。这样的复杂度是$O(\\log n)$，总复杂度是$O(n\\log^2n)$ 方法3： 倍增做法​ 我们定义$sa[i]$表示排名为i的后缀的开始位置，$rank[i]$表示后缀$suf(i)$的排名。显然有如下结论：$sa[rank[i]] = i$，$rank[sa[i]] = i$，即sa和rank互为反函数 ​ 定义$sub[i][k]$表示str从i开始长度为k的子串(若长度超过了str的范围，则之后的都视为空)。$rank[i][k]$表示$sub[i][k]$在所有长度为$2^k$的子串中的排名，$sa[i][k]$表示所有长度为$2^k$的子串中，排名为i的子串是从哪里开始的 ​ step1：首先求出所有$sub[1][0],sub[2][0],……,sub[n][0]$的字典排序 ​ step2：求出所有$sub[1][1],sub[2][1],……,sub[n][1]$的字典排序 ​ …… ​ 当子串长度$2^k&gt;n$时，子串的排序就是我的后缀排序（一共做$\\lceil \\log k\\rceil$次） ​ 那么我们如何快速的求出$sub[1][k+1],sub[2][k+1],……,sub[n][k+1]$的字典排序呢？利用$sub[1][k],sub[2][k],……,sub[n][k]$的结果 ​ 对于$sub[i][k+1]和sub[j][k+1]$我们可以分成两部分来比较，第一部分是$sub[i][k]和sub[j][k]$，第二部分是$sub[i+2^k-1][k]和sub[j+2^k-1][k]$ ​ 如果两者第一部分就不同，那么我们根据$rank[i][k]和rank[j][k]$就可以判断两者的大小 ​ 如果第一部分相同，就根据$rank[i+2^k-1][k]和rank[j+2^k-1][k]$比较两者的大小 ​ 如果把这两部分看成是pair的话，就是比较$\\{rank[i][k],rank[i+2^k-1][k] \\}和\\{rank[j[k],rank[j+2^k-1][k] \\}$，当然这里有一个显而易见的优化，我的$rank[i][k+1]$和$sa[i][k+1]$只和$rank[i][k]和rank[j][k]$有关，所以可以使用滚动数组 ​ 这里我们利用基数排序来比较他们的大小，对于基数排序来说，需要先比较second再比较first ​ 于是有如下代码: 先对second进行排序 123for (i = 1; i &lt;= n; ++i) ++cnt[rk[id[i] + w]];\t//w代表2^k,id[i]表示我之前的sa[i]for (i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1];for (i = n; i &gt;= 1; --i) sa[cnt[rk[id[i] + w]]--] = id[i];\t//注意这里需要倒序 再对first进行排序 123for (i = 1; i &lt;= n; ++i) ++cnt[rk[id[i]]];\t//同理这里的id[i]就是我之前的sa[i]for (i = 1; i &lt;= m; ++i) cnt[i] += cnt[i - 1];for (i = n; i &gt;= 1; --i) sa[cnt[rk[id[i]]]--] = id[i];\t//同理这里也需要倒序 最后把我的结果转移到新的rank中，对于排序后相邻的两个sub，如果他们的first和second都相等，那他们更新后的rank也相等 12345678for (p = 0, i = 1; i &lt;= n; ++i) &#123;\tif (oldrk[sa[i]] == oldrk[sa[i - 1]] &amp;&amp;\t//这里的oldrk[i]表示我之前的rank[i] oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) &#123; rk[sa[i]] = p; &#125; else &#123; rk[sa[i]] = ++p; &#125;&#125; 倍增算法的一点优化1.第二关键字无需基数排序​ 第二关键字排序的实质，其实就是把对于$sa[i]+w&gt;n$的后缀，放到id的头部，因为前后两次唯一会产生变化次序的位置，就是我满足$sa[i]+w&gt;n$的所有i。在$len=w/2$时，他们的第二关键字&gt;0，在$len=w$时，他们的第二关键字=0。 ​ 因此得到如下的代码 1234int cur = 0;for (int i = n - w + 1; i &lt;= n; i++) id[++cur] = i;for (int i = 1; i &lt;= n; i++) if (sa[i] &gt; w) id[++cur] = sa[i] - w; 2.值域的优化​ 一开始我们利用的是ascall码作为值域，事实上值域不需要这么大，利用我们最后合并时得到的不同种类p即可 3. 若排名不同可以直接输出后缀数组​ 当种类(p) = 字符串的长度(n)时，后缀数组其实已经排好了，直接输出即可 所以综上优化，得到我的后缀数组的模板 123456789101112131415161718192021222324252627for (int i = 1; i &lt;= n; i++) cnt[rk[i] = s[i]]++;for (int i = 1; i &lt;= m; i++) cnt[i] += cnt[i - 1];for (int i = n; i &gt;= 1; i--) sa[cnt[rk[i]]--] = i;for (int w = 1;; w &lt;&lt;= 1, m = p) &#123; // m = p 即为值域优化 int cur = 0; for (int i = n - w + 1; i &lt;= n; i++) id[++cur] = i; for (int i = 1; i &lt;= n; i++) if (sa[i] &gt; w) id[++cur] = sa[i] - w; memset(cnt, 0, sizeof(cnt)); for (int i = 1; i &lt;= n; i++) cnt[rk[i]]++; for (int i = 1; i &lt;= m; i++) cnt[i] += cnt[i - 1]; for (int i = n; i &gt;= 1; i--) sa[cnt[rk[id[i]]]--] = id[i]; p = 0; memcpy(oldrk, rk, sizeof(oldrk)); for (int i = 1; i &lt;= n; i++) &#123; if (oldrk[sa[i]] == oldrk[sa[i - 1]] &amp;&amp; oldrk[sa[i] + w] == oldrk[sa[i - 1] + w]) rk[sa[i]] = p; else rk[sa[i]] = ++p; &#125; if (p == n) break; // p = n 时无需再排序&#125; 2. 利用后缀数组，得到两个后缀的lcp我们定义$height[i]=lcp(suf_{sa[i-1]},suf_{sa[i]})$值得注意的是，这里的两个后缀的后缀数组sa中相邻的两个 那如果我想得到任意的两个后缀的lcp呢？有结论 $lcp(suf_i,suf_j)=min_{k=l+1}^{r}(height[k])$，其中$l=sa[suf_i],r=sa[suf_j]$，这里可以维护一个RMQ实现证明： ​ 首先证明对于$s1&lt;s2&lt;s3有lcp(s1,s3)=min(lcp(s1,s2),lcp(s2,s3))$ 以下图中的黑色代表$lcp(s_1,s_2)$红色代表$lcp(s_2,s_3)$ 对于这种情况显然成立，假设说我的$lcp(s_1,s_3)&gt;lcp(s_2,s_3)$，则有$s_3[i+1] e s_2[i+1],s_3[i+1]=s_1[i+1]\\rightarrow s_1[i+1] e s_2[i+1]$，与我的假设矛盾 同理以上case1的情况，也能得到结论成立 当我三个长度都相等的时候，如果说此时$lcp(s_1,s_3)&gt;lcp(s_2,s_3)$那么，就有$b e c \\land b e a$，那么此时我的$s_1,s_2,s_3$的排序就不是这样的，应该是$s_1,s_3,s_2,即s_2不会在s_1,s_3之间$，故假设矛盾。 综上我们的结论成立。 ​ 之后再从s1,s3之间找出所有的$s_i$都满足$lcp(s1,s3)=min(lcp(s_1,s_i),lcp(s_i,s_3))$，即可得证。(不严格的证明) ​ 那么如何快速求解height，有结论 $height[l]\\ge height[r]-1,其中l=rank[i],r=rank[i-1]$不会证明，记住就行 有如下代码，求height 123456for (i = 1, k = 0; i &lt;= n; ++i) &#123; if (rk[i] == 0) continue; if (k) --k; while (s[i + k] == s[sa[rk[i] - 1] + k]) ++k; height[rk[i]] = k;&#125; ​ ​"},{"title":"后缀自动机(SAM)","path":"/2024/06/07/后缀自动机-SAM/","content":"后缀自动机1. 后缀自动机实现的功能给定一个string,例如为“aabab”他有后缀b, ab, bab等，需要把他们构建在同一个trie上，如果暴力地构建得到以下trie结构 如上图所示，但是我们会发现一个问题，节点个数有 $O(n^2)$个，但是我们可以发现 两个红色矩形内代表的后缀子串都是bab，因此可以化简为以下形式 因此，我们想要找到一个节点数和边数尽可能少的DAG 2. 后缀自动机的构建定义：我们定义endpos(a)表示a子串在整个string中出现的位置（只记录最右的位置） 例如对于string = “abbab”,下标对应12345 我的endpos(“ab”) = {2，5}，endpos(“bab”) = {5} 现在可以证明三个结论 （1）如果两个子串的endpos相同，则其中一个子串一定是另一个的后缀对于两个子串s,t，要求len(s) $\\le$ len(t)，那么如果我的s不是t的后缀，则会出现以下的情况 因为s不是t的后缀所以一定存在一个位置（绿色的位置）使得t[i]$ eq$s[i] 但是既然我的s与t的endpos相同，放在整个string串上来看t[i - x] = s[i - x]，即绿色位置必然是相等的，与前提矛盾，所以反证法成立 （2）对于任意两个子串t，p满足len(t)$\\le$len(s),要么endpos(t)$\\subseteq$endpos(s),要么endpos(t)$\\cap$endpos(s) = $\\emptyset$分为两种情况来讨论： case1：t是s的后缀，则显然有endpos(t)$\\subseteq$endpos(s) case2 ：t不是s的后缀，根据我的推论1，两个子串的endpos必然不同，即endpos(t)$\\cap$endpos(s) = $\\emptyset$ （3）对于endpos相同的子串，可以视作一个等价类，满足子串长度连续，且均为后缀例如对于“aabab”，endpos=4的子串有aaba,aba,ba,a可以发现长度连续，且后一个为前一个的后缀 显然有长度覆盖的区间是连续的 对于后缀结论，通过推论2，可得：endpos(t)$\\subseteq$endpos(s)$\\Rightarrow$t是s的后缀 （4）endpos的等价类个数有$O(n)$个对于一个类，我一定能从中找到一个长度最长的字符串s，此时我在s前加上一个字符，记作newstr 那么此时我的newstr一定不存在我的endpos=endpos(s)所代表的string集合中，因此得到了一个新的等价类，但是我的endpos(newstr)$\\subset$endpos(s) 如果我在s前加上两个不相同的字符（记作str2）呢？显然此时有endpos(str2)$\\cap$endpos(newstr)=$\\emptyset$，因此我的str2和newstr分别代表的等价类可以视作endpos(s)的划分，不会超过原有集合的大小，因此所有的等价类加在一起不会超过$2|endpos(s)|$个，因此可以视作是$O(n)$的 此时给出如下定义：若集合B是我集合A的一个划分，则称A是B的父亲 （5）一个等价类a，称最长的子串为len(a)，最短的子串为minlen(a)，设fa(a)表示类a的父亲，有len(fa(a)) + 1 = minlen(a)这是显然的，因为我在endpos(a)的最长str前加上一个字符,得到的endpos记作b，根据推论4，fa(b) = a，且此时的c + strZ一定是集合b中最短的str 此时我们可以尝试给出aababa的后缀自动机形式了(图中节点旁边写的str代表该endpos集合包含的最长str) 后缀自动机的最终形态并不是如此，还需要加上边，使得从源点出发到节点i的任意一条路径形成的字符串都是属于i的等价类 图中黑色的线代表的是parent tree的边，蓝色的线是后缀自动机的边 我们可以理解为沿着parent tree的边跑，相当于在字符串前面添加字符，而沿着后缀自动机的边跑，相当于在字符串后面添加字符"},{"title":"post title","path":"/2024/06/05/post-title/","content":"后缀自动机1. 后缀自动机实现的功能给定一个string,例如为“abbaba”他有后缀a, ba,, aba等，需要把他们构建在同一个trie上，如果暴力地构建得到以下"},{"title":"Hello World","path":"/2024/06/05/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]